{"version":3,"sources":["webpack:///./src/helpers/account_helper.ts","webpack:///./src/js/wallets/MnemonicWallet.ts","webpack:///./src/js/ERC721Token.ts","webpack:///./src/js/AvaNetwork.ts","webpack:///./src/js/Erc20Token.ts","webpack:///./src/js/TxHelper.ts","webpack:///./src/js/Crypto.ts","webpack:///./src/js/Keystore.ts","webpack:///./src/explorer_api.ts","webpack:///./src/evm.ts","webpack:///./src/helpers/price_helper.ts","webpack:///./src/js/HdHelper.ts","webpack:///./src/js/wallets/HdWalletCore.ts","webpack:///./src/helpers/history_helper.ts","webpack:///./src/js/wallets/LedgerWallet.ts","webpack:///./src/locales/lang_map.js","webpack:///./src/helpers/utxo_helper.ts","webpack:///./src/js/wallets/SingletonWallet.ts","webpack:///./src/js/AvaNftFamily.ts","webpack:///./src/js/wallets/WalletCore.ts","webpack:///./src/helpers/wallet_helper.ts","webpack:///./src/helpers/helper.ts","webpack:///./src/js/AvaAsset.ts"],"names":["getAccountByIndex","index","getLocalStorageAccounts","removeAccountByIndex","accounts","splice","saveLocalStorageJSONItem","getLocalStorageJSONItem","key","item","localStorage","getItem","JSON","parse","data","formatted","stringify","setItem","addAccountToStorage","account","push","verifyAccountPassword","password","wallet","overwriteAccountAtIndex","newAccount","accts","AVA_TOKEN_INDEX","AVA_ACCOUNT_PATH","ETH_ACCOUNT_PATH","LEDGER_ETH_ACCOUNT_PATH","mnemonic","seed","masterHdKey","fromMasterSeed","accountHdKey","derive","ethAccountKey","ethPrivateKey","privateKey","ethKey","toString","ethAddress","ethBalance","cPrivKey","cb58Encode","from","ethKeyBech","cKeyChain","getHRP","ethKeyChain","cKeypair","importKey","ethAddressBech","getAddressString","type","hdKey","isLoading","onnetworkchange","this","getEvmAddress","getEvmAddressBech","getEthBalance","bal","sendEth","to","amount","gasPrice","gasLimit","estimateGas","token","Promise","sendERC20","sendErc20","getUTXOs","isFetchUtxos","isInit","externalHelper","internalHelper","platformHelper","getStake","setTimeout","getCurrentKey","getMnemonic","validate","nodeID","amt","start","end","delegationFee","rewardAddress","utxos","delegate","stakeAmount","exportFromPChain","exportFromXChain","destinationChain","exportFromCChain","importToCChain","importToPlatformChain","importToXChain","sourceChain","issueBatchTx","orders","addr","memo","getKeyChain","internal","getAllDerivedKeys","external","allKeys","concat","keychain","getNetworkID","chainId","i","length","addKey","signX","unsignedTx","tx","sign","signP","getKeychain","signC","keyChain","signEvm","keyBuff","Buffer","signHashByExternalIndex","hash","getKeyForIndex","signed","createNftFamily","name","symbol","groupNum","mintNft","mintUtxo","payload","quantity","ERC721MetadataID","ERC721EnumerableID","tokenCache","uriDataCache","canSupport","contractAddress","address","contract","eth","Contract","abi","updateSupports","methods","supportsInterface","call","metadata","enumerable","getBalance","balanceOf","getAllTokensIds","res","tokenOfOwnerByIndex","tokenId","getAllTokenData","ids","id","getTokenURI","parseInt","createTransferTx","transferFrom","tokenURI","getTokenURIData","uri","a","get","network_id","url","networkId","explorerUrl","explorerSiteUrl","readonly","withCredentials","protocol","port","ip","updateURL","testConnection","credentials","post","jsonrpc","method","catch","err","updateCredentials","split","includes","urlSplit","getFullURL","getWsUrlX","getWsUrlC","tokenData","balanceRaw","balanceBN","balanceBig","tokenInst","fromAddress","console","log","transfer","updateBalance","decimals","AvmTxNameEnum","PlatfromTxNameEnum","ParseableAvmTxEnum","ParseablePlatformEnum","ParseableEvmTxEnum","buildUnsignedTransaction","derivedAddresses","utxoset","changeAddress","fromAddrsStr","fromAddrs","map","val","parseAddress","changeAddr","stringToAddress","getDJTXAssetID","DJTX_ID_BUF","DJTX_ID_STR","TO_BUF","aad","ZERO","isFeeAdded","order","asset","assetId","cb58Decode","addAssetAmount","getTxFee","gt","success","getMinimumSpendable","ins","outs","getInputs","getAllOutputs","nftUtxos","filter","getBlockchainID","nftSet","addArray","utxoIds","getUTXOIDs","sort","b","buildNFTTransferTx","undefined","rawTx","getTransaction","outsNft","getOuts","insNft","getIns","baseTx","buildCreateNftFamilyTx","minterAddr","utxoSet","fromAddresses","minterAddress","minterSets","minterSet","buildCreateNFTAssetTx","buildMintNftTx","ownerAddress","addrBuf","owners","sourceAddresses","owner","groupID","getOutput","getGroupID","buildCreateNFTMintTx","getUTXOID","mintTx","buildAvmExportTransaction","toAddress","sourceChangeAddress","destinationChainId","buildExportTx","buildEvmExportTransaction","fromAddressBech","getTransactionCount","nonce","djtxAssetIDBuf","djtxAssetIDStr","fromAddressHex","buildEvmTransferNativeTx","getChainId","net","getId","chainParams","common","forCustomChain","value","buildEvmTransferErc20Tx","tokenTx","encodeABI","buildEvmTransferErc721Tx","BASETX","CREATEASSETTX","OPERATIONTX","IMPORTTX","EXPORTTX","ADDVALIDATORTX","ADDDELEGATORTX","ADDSUBNETVALIDATORTX","CREATECHAINTX","CREATESUBNETTX","ADVANCETIMETX","REWARDVALIDATORTX","ivSize","saltSize","tagLength","aesLength","keygenIterations","_pwcleaner","slt","pw","sha256","_keyMaterial","pwkey","window","crypto","subtle","Uint8Array","_deriveKey","keyMaterial","salt","deriveKey","iterations","message","buff","update","digest","makeSalt","alloc","getRandomValues","pwhash","encrypt","plaintext","pt","pkey","iv","additionalData","ciphertext","decrypt","cryptoHelpers","Crypto","KEYSTORE_VERSION","ITERATIONS_V2","ITERATIONS_V3","readV2","pass","version","pass_hash","checkHash","checkHashString","keys","keysDecrypt","key_data","key_decrypt","key_string","activeIndex","readV3","readV4","readV5","readV6","readKeyFile","extractKeysV2","file","chainID","getBlockchainAlias","pk","keypair","keyBuf","getPrivateKey","keyHex","paddedKeyHex","padStart","extractKeysV5","extractKeysV6","extractKeysFromDecryptedFile","makeKeyfile","wallets","pk_crypt","file_data","api_url","explorer_api","create","baseURL","headers","getAddressHistory","addrs","limit","endTime","ADDR_SIZE","selection","slice","remaining","addrsRaw","rootUrl","req","disableCount","disableGenesis","txs","transactions","next","nextRes","getAddressChains","rawAddrs","urlRoot","addressChains","abiDecoder","addABI","rpcUrl","web3","axios","COIN_ID","COINGECKO_URL","coingeckoApi","timeout","getDjtxPriceUSD","priceHistory","getPriceHistory","params","vs_currency","days","interval","prices","getPriceAtUnixTime","time","remainder","dayTimestamp","pricePair","find","INDEX_RANGE","SCAN_SIZE","SCAN_RANGE","changePath","masterKey","isPublic","isFetchUtxo","hrp","keyCache","addressCache","hdCache","hdIndex","oninit","findHdIndex","onNetworkChange","clearCache","incrementIndex","newIndex","newKey","network","store","state","Network","selectedNetwork","findAvailableIndexExplorer","findAvailableIndexNode","updateKeychain","updateUtxos","error","getAllDerivedAddresses","result","currentAddr","getCurrentAddress","currentAddrBuf","currentUtxos","getExtendedAddresses","getUtxos","upTo","set","getAddressForIndex","startIndex","addrChains","gapSize","n","scanIndex","scanAddr","rawAddr","chains","addrUTXOs","targetIndex","getFirstAvailableIndex","getFirstAvailableAddress","idx","isPrivate","cacheExternal","pkHex","derivationPath","publicKey","pkBuf","pkBuff","addressFromPublicKey","addressToString","findAddressIndex","indexOf","then","updateInitState","getUTXOSet","updateAvmUTXOSet","setExternal","setInternal","joined","merge","getFirstAvailableAddressPlatform","updateFetchState","updateUTXOsX","updateUTXOsP","updateUTXOsExternal","updateUTXOsInternal","getAllDerivedExternalAddresses","getDerivedAddresses","getDerivedAddressesP","getAllAddressesX","getAllAddressesP","getHistoryAddresses","internalIndex","externalIndex","Math","max","getCurrentAddressAvm","getChangeAddressAvm","getChangeAddressPlatform","getChangePath","getChangeIndex","getChangeFromIndex","getPlatformRewardAddress","getCurrentAddressPlatform","getPlatformUTXOSet","getPlatformActiveIndex","getExternalActiveIndex","getBaseAddress","findExternalAddressIndex","indexX","indexP","Error","signMessageByExternalAddress","msgStr","signMessageByExternalIndex","digestHex","digestBuff","signMessage","msg","WalletCore","addToDict","dict","utxo","addresses","add","addrDiff","getNFTsSummary","nftLoss","getLossNFT","nftGain","getGainNFT","sent","received","walletAddrs","addrsStripped","inputs","outputs","loss","assets","nfts","input","output","outputType","NFTXFEROUTPUTID","nftsOuts","assetID","intersect","nftOut","doesMatch","addrNotAdded","gain","nftsIns","nftIn","getLoss","isNft","amountBN","receivers","forEach","outAddrs","targets","getProfit","profit","senders","getTransactionSummary","losses","profits","nftSummary","sum","tokens","collectibles","mul","filterDuplicateTransactions","txsIds","filtered","txId","bippath","MIN_EVM_SUPPORT_V","app","hdkey","config","hdEth","ethApp","ethPublic","pubKeyHash","fromApp","getWalletExtendedPublicKey","hd","public_key","chainCode","chain_code","getAddress","ethRes","LedgerWallet","getTransactionPaths","txType","getTxType","operations","getOperations","e","items","getImportInputs","paths","isDjtxOnly","getAssetID","Assets","AVA_ASSET_ID","sigidxs","getInput","getSigIdxs","sources","sigidx","source","j","srcAddr","pathStr","getPathFromAddress","op","getOperation","pathsToUniqueBipPaths","uniquePaths","bip32Paths","path","fromString","getChangeBipPath","chainChangePath","changeIdx","getCredentials","sigMap","CredentialClass","creds","evmInputs","cred","getCredentialID","pathIndex","sigRaw","sigBuff","sig","fromBuffer","addSignature","evmInput","signTransactionHash","txbuff","toBuffer","commit","title","messages","info","toUpperCase","accountPath","signHash","signedTx","signTransactionParsable","parseableTxs","X","P","C","getTransactionMessages","signTransaction","ledgerSignedTx","signatures","getOutputMsgs","getExportOutputs","getExportedOutputs","getAmount","toPathArray","getAddresses","getValidateDelegateMsgs","format","getNodeID","startTime","getStartTime","toNumber","utc","getEndTime","stakeAmt","getStakeAmount","rewardOwners","getRewardOwners","rewardAddrs","join","getFeeMsgs","outputMessages","validateDelegateMessages","feeMessages","getEvmTransactionMessages","totFee","feeNano","msgs","test","decodeMethod","callMsg","paramMsgs","param","feeMsg","toLocaleString","canLedgerParse","isParsableType","txIns","typeID","getTypeID","STAKEABLELOCKINID","typeId","txSigned","rawUnsignedTx","encode","buf","signature","signatureBN","v","r","s","fromTxData","externalAddrs","internalAddrs","platformAddrs","extIndex","intIndex","platformIndex","addressPath","isoLangs","ab","nativeName","aa","af","ak","sq","am","ar","an","hy","as","av","ae","ay","az","bm","ba","eu","be","bn","bh","bi","bs","br","bg","my","ca","ch","ce","ny","cn","zh_hans","zh_hant","cv","kw","co","cr","hr","cs","da","dv","nl","en","eo","et","ee","fo","fj","fi","fr","ff","gl","ka","de","el","gn","gu","ht","ha","he","hz","hi","ho","hu","ia","ie","ga","ig","ik","io","is","it","iu","ja","jv","kl","kn","ks","kk","km","ki","rw","ky","kv","kg","kr","ku","kj","la","lb","lg","li","ln","lo","lt","lu","lv","gv","mk","mg","ms","ml","mt","mi","mr","mh","mn","na","nv","nb","nd","ne","ng","nn","no","ii","nr","oc","oj","cu","om","or","os","pa","pi","fa","pl","ps","qu","rm","rn","ro","ru","sa","sc","sd","se","sm","sg","sr","gd","sn","si","sk","sl","so","st","es","su","sw","ss","sv","ta","te","tg","th","ti","bo","tk","tl","tn","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vn","vo","wa","cy","wo","fy","xh","yi","yo","za","getStakeForAddresses","stakeData","staked","chunk","remainingChunk","chunkStake","avmGetAllUTXOs","avmGetAllUTXOsForAddresses","newSet","endIndex","response","getAllUTXOs","nextEndIndex","len","numFetched","subUtxos","platformGetAllUTXOs","platformGetAllUTXOsForAddresses","chainIdP","keyPair","platformKeyChain","platformKeyPair","pkBuffNative","getExtendedPlatformAddresses","platformUtxoset","uniqid","issueTx","pAddressStrings","stakeReturnAddr","round","getTime","buildAddValidatorTx","buildAddDelegatorTx","avmGetAtomicUTXOs","platformGetAtomicUTXOs","evmGetAtomicUTXOs","xToAddr","utxoAddrs","ownerAddrs","sourceChainId","buildImportTx","pToAddr","bechAddr","hexAddr","ownerAddresses","fee","amtFee","destinationAddr","exportTx","pChangeAddr","xId","fromAddr","txHex","serialize","sendSignedTransaction","transactionHash","sendErc721","estimateTxGas","estGas","bnToBig","denomination","div","pow","keyToKeypair","calculateStakingReward","duration","currentSupply","networkID","defValues","maxConsumption","minConsumption","diffConsumption","maxSupply","maxStakingDuration","remainingSupply","sub","amtBig","currentSupplyBig","remainingSupplyBig","portionOfExistingSupplyBig","portionOfStakingDuration","mintingRate","rewardBig","times","rewardStr","toFixed","rewardBN","digestMessage","mBuf","msgSize","writeUInt32BE","msgBuf","payloadtypes","getInstance","getPayloadFromUTXO","out","getPayloadBuffer","getContent","payloadbase","select","amountLocked","amountExtra","addBalance","addBalanceLocked","addExtra","resetBalance","locked","getAmountBN","getTotalAmount","toStringTotal","big"],"mappings":"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","file":"js/app~63defed8.4000aba8.js","sourcesContent":["import { iUserAccountEncrypted } from '@/store/types'\nimport { WalletType } from '@/js/wallets/types'\nimport isEqual from 'lodash.isequal'\nimport differenceBy from 'lodash.differenceby'\nimport { readKeyFile } from '@/js/Keystore'\n\nconst checkAccountsExist = (): boolean => {\n    return localStorage.getItem('accounts') !== null\n}\n\nexport function getAccountByIndex(index: number): iUserAccountEncrypted | null {\n    return getLocalStorageAccounts()[index] || null\n}\n\nexport const checkIfSavedLocally = (allWallets: WalletType[]): boolean => {\n    const exists = checkAccountsExist()\n\n    if (!exists) return false\n\n    let ethAddressArray: string[] = allWallets.map((x: WalletType) => x.ethAddress)\n\n    const savedAccounts: iUserAccountEncrypted[] = getLocalStorageJSONItem('accounts')\n\n    for (const each of savedAccounts) {\n        if (isEqual(each.baseAddresses, ethAddressArray)) {\n            return true\n        }\n    }\n\n    return false\n}\nexport const removeAccountByIndex = (index: number): void => {\n    const accounts: iUserAccountEncrypted[] = getLocalStorageAccounts()\n    accounts.splice(index, 1)\n    saveLocalStorageJSONItem('accounts', accounts)\n}\n\nexport const getLocalStorageJSONItem = (key: string) => {\n    let item = localStorage.getItem(key)\n    if (item !== null) {\n        return JSON.parse(item)\n    }\n}\n\nexport function getLocalStorageAccounts(): iUserAccountEncrypted[] {\n    return getLocalStorageJSONItem('accounts') || []\n}\n\nexport const saveLocalStorageJSONItem = (key: string, data: any) => {\n    let formatted = JSON.stringify(data)\n    localStorage.setItem(key, formatted)\n}\n\nexport const getIndexByWallets = (wallets: WalletType[]): number | null => {\n    let ethAddressArray: string[] = wallets.map((x: WalletType) => x.getEvmAddress())\n    const savedAccounts: iUserAccountEncrypted[] = getLocalStorageAccounts()\n    let index = 0\n    for (var i = 0; i < savedAccounts.length; i++) {\n        let acct = savedAccounts[i]\n        if (isEqual(acct.baseAddresses, ethAddressArray)) {\n            return index\n        }\n    }\n    return null\n}\n\nexport const getNonVolatileWallets = (\n    allWallets: WalletType[],\n    volatileWallets: WalletType[]\n): WalletType[] | [] => {\n    let diff = differenceBy(allWallets, volatileWallets, 'ethAddress')\n    diff === undefined ? [] : diff\n    return diff\n}\n\nexport function addAccountToStorage(account: iUserAccountEncrypted) {\n    let accounts = getLocalStorageAccounts()\n    accounts.push(account)\n    saveLocalStorageJSONItem('accounts', accounts)\n}\n\n// Given a password and an account, will verify if its the correct password\nexport async function verifyAccountPassword(account: iUserAccountEncrypted, password: string) {\n    try {\n        let res = await readKeyFile(account.wallet, password)\n        return true\n    } catch (err) {\n        return false\n    }\n}\n\nexport function overwriteAccountAtIndex(newAccount: iUserAccountEncrypted, index: number) {\n    let accts = getLocalStorageAccounts()\n    accts.splice(index, 1, newAccount)\n    saveLocalStorageJSONItem('accounts', accts)\n}\n\nexport default {\n    removeAccountByIndex,\n    checkIfSavedLocally,\n    getNonVolatileWallets,\n}\n","// A simple wrapper thar combines avalanche.js, bip39 and HDWallet\n\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    TransferableInput,\n    TransferableOutput,\n    BaseTx,\n    UnsignedTx as AVMUnsignedTx,\n    Tx as AVMTx,\n    UTXO as AVMUTXO,\n    AssetAmountDestination,\n    UTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { privateToAddress } from 'ethereumjs-util'\n\nimport {\n    KeyChain as PlatformVMKeyChain,\n    UnsignedTx as PlatformUnsignedTx,\n    UTXO as PlatformUTXO,\n    Tx as PlatformTx,\n} from 'avalanche/dist/apis/platformvm'\n\nimport {\n    KeyChain as EVMKeyChain,\n    UnsignedTx as EVMUnsignedTx,\n    Tx as EvmTx,\n} from 'avalanche/dist/apis/evm'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\n\nimport * as bip39 from 'bip39'\nimport { BN, Buffer as BufferAvalanche } from 'avalanche'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { AvmExportChainType, AvmImportChainType, IAvaHdWallet } from '@/js/wallets/types'\nimport HDKey from 'hdkey'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { KeyPair as PlatformVMKeyPair } from 'avalanche/dist/apis/platformvm'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { WalletNameType } from '@/js/wallets/types'\nimport { digestMessage } from '@/helpers/helper'\nimport { KeyChain } from 'avalanche/dist/apis/evm'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { Transaction } from '@ethereumjs/tx'\n\n// HD WALLET\n// Accounts are not used and the account index is fixed to 0\n// m / purpose' / coin_type' / account' / change / address_index\n\nconst AVA_TOKEN_INDEX: string = '9000'\nexport const AVA_ACCOUNT_PATH: string = `m/44'/${AVA_TOKEN_INDEX}'/0'` // Change and index left out\nexport const ETH_ACCOUNT_PATH: string = `m/44'/60'/0'`\nexport const LEDGER_ETH_ACCOUNT_PATH = ETH_ACCOUNT_PATH + '/0/0'\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\nconst SCAN_SIZE: number = 70 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\n\n// Possible indexes for each request is\n// SCAN_SIZE - INDEX_RANGE\n\nexport default class MnemonicWallet extends HdWalletCore implements IAvaHdWallet {\n    seed: string\n    hdKey: HDKey\n    mnemonic: string\n    isLoading: boolean\n    type: WalletNameType\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethAddressBech: string\n    ethBalance: BN\n\n    // TODO : Move to hd core class\n    onnetworkchange() {\n        super.onnetworkchange()\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        let cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethAddressBech = cKeypair.getAddressString()\n        this.ethBalance = new BN(0)\n    }\n\n    // The master key from avalanche.js\n    constructor(mnemonic: string) {\n        let seed: globalThis.Buffer = bip39.mnemonicToSeedSync(mnemonic)\n        let masterHdKey: HDKey = HDKey.fromMasterSeed(seed)\n        let accountHdKey = masterHdKey.derive(AVA_ACCOUNT_PATH)\n\n        super(accountHdKey, false)\n\n        // Derive EVM key and address\n        let ethAccountKey = masterHdKey.derive(ETH_ACCOUNT_PATH + '/0/0')\n        let ethPrivateKey = ethAccountKey.privateKey\n        this.ethKey = ethPrivateKey.toString('hex')\n        this.ethAddress = privateToAddress(ethPrivateKey).toString('hex')\n        this.ethBalance = new BN(0)\n\n        let cPrivKey = `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(ethPrivateKey))\n        this.ethKeyBech = cPrivKey\n\n        let cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        let cKeypair = cKeyChain.importKey(cPrivKey)\n        this.ethAddressBech = cKeypair.getAddressString()\n\n        this.type = 'mnemonic'\n        this.seed = seed.toString('hex')\n        this.hdKey = masterHdKey\n        this.mnemonic = mnemonic\n        this.isLoading = false\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    getEvmAddressBech(): string {\n        return this.ethAddressBech\n    }\n\n    async getEthBalance() {\n        let bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        let isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            // console.info('HD Not ready try again in 1 sec..')\n            return\n        }\n\n        super.getUTXOs()\n        this.getStake()\n        this.getEthBalance()\n        return\n    }\n\n    getCurrentKey(): AVMKeyPair {\n        return this.externalHelper.getCurrentKey() as AVMKeyPair\n    }\n\n    getMnemonic(): string {\n        return this.mnemonic\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    // Delegates DJTX to the given node ID\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    async exportFromPChain(amt: BN) {\n        return await WalletHelper.exportFromPChain(this, amt)\n    }\n\n    async exportFromXChain(amt: BN, destinationChain: AvmExportChainType) {\n        return await WalletHelper.exportFromXChain(this, amt, destinationChain)\n    }\n\n    async exportFromCChain(amt: BN) {\n        return await WalletHelper.exportFromCChain(this, amt)\n    }\n\n    async importToCChain(): Promise<string> {\n        return await WalletHelper.importToCChain(this)\n    }\n\n    async importToPlatformChain(): Promise<string> {\n        return await WalletHelper.importToPlatformChain(this)\n    }\n\n    async importToXChain(sourceChain: AvmImportChainType) {\n        return await WalletHelper.importToXChain(this, sourceChain)\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: BufferAvalanche | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    // returns a keychain that has all the derived private/public keys for X chain\n    getKeyChain(): AVMKeyChain {\n        let internal = this.internalHelper.getAllDerivedKeys() as AVMKeyPair[]\n        let external = this.externalHelper.getAllDerivedKeys() as AVMKeyPair[]\n\n        let allKeys = internal.concat(external)\n        let keychain: AVMKeyChain = new AVMKeyChain(\n            getPreferredHRP(ava.getNetworkID()),\n            this.chainId\n        )\n\n        for (var i = 0; i < allKeys.length; i++) {\n            keychain.addKey(allKeys[i])\n        }\n        return keychain\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        let keychain = this.getKeyChain()\n\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        let keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        let keyChain = this.ethKeyChain\n        return unsignedTx.sign(keyChain)\n    }\n\n    async signEvm(tx: Transaction) {\n        let keyBuff = Buffer.from(this.ethKey, 'hex')\n        return tx.sign(keyBuff)\n    }\n\n    async signHashByExternalIndex(index: number, hash: BufferAvalanche) {\n        let key = this.externalHelper.getKeyForIndex(index) as AVMKeyPair\n        let signed = key.sign(hash)\n        return bintools.cb58Encode(signed)\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n}\n","import { web3 } from '@/evm'\nimport ERC721Abi from '@openzeppelin/contracts/build/contracts/ERC721.json'\nimport { ERC721TokenInput } from '@/store/modules/assets/modules/types'\nimport axios from 'axios'\nimport { BN } from 'avalanche'\n\ninterface TokenDataCache {\n    [index: number]: string\n}\n\ninterface URIDataCache {\n    [index: number]: string\n}\n\nconst ERC721MetadataID = '0x5b5e139f'\nconst ERC721EnumerableID = '0x780e9d63'\n\nclass ERC721Token {\n    contractAddress: string\n    contract: any\n    name = ''\n    symbol = ''\n    data: ERC721TokenInput\n    tokenCache: TokenDataCache = {}\n    uriDataCache: URIDataCache = {}\n    canSupport = false\n\n    constructor(data: ERC721TokenInput) {\n        this.contractAddress = data.address\n        this.name = data.name\n        this.symbol = data.symbol\n        this.data = data\n        //@ts-ignore\n        this.contract = new web3.eth.Contract(ERC721Abi.abi, this.contractAddress)\n        this.updateSupports()\n    }\n\n    async updateSupports() {\n        try {\n            let metadata = await this.contract.methods.supportsInterface(ERC721MetadataID).call()\n            let enumerable = await this.contract.methods\n                .supportsInterface(ERC721EnumerableID)\n                .call()\n            this.canSupport = metadata && enumerable\n        } catch (err) {\n            this.canSupport = false\n            // console.error(err)\n        }\n    }\n\n    async getBalance(address: string) {\n        return await this.contract.methods.balanceOf(address).call()\n    }\n\n    async getAllTokensIds(address: string): Promise<string[]> {\n        if (!this.canSupport) return []\n\n        let bal = await this.getBalance(address)\n        let res = []\n        for (var i = 0; i < bal; i++) {\n            let tokenId = await this.contract.methods.tokenOfOwnerByIndex(address, i).call()\n            res.push(tokenId)\n        }\n        return res\n    }\n\n    async getAllTokenData(address: string) {\n        let ids = await this.getAllTokensIds(address)\n\n        let res = []\n        for (var i = 0; i < ids.length; i++) {\n            let id = ids[i]\n            let data = await this.getTokenURI(parseInt(id))\n            res.push(data)\n        }\n        return res\n    }\n\n    createTransferTx(from: string, to: string, id: string) {\n        return this.contract.methods.transferFrom(from, to, id)\n    }\n\n    async getTokenURI(id: number) {\n        if (this.tokenCache[id]) return this.tokenCache[id]\n        let data = await this.contract.methods.tokenURI(id).call()\n        this.tokenCache[id] = data\n        return data\n    }\n\n    async getTokenURIData(id: number): Promise<any> {\n        //Check cache\n        if (this.uriDataCache[id]) return this.uriDataCache[id]\n        let uri = await this.getTokenURI(id)\n        if (!uri) return null\n        let res = (await axios.get(uri)).data\n        //Save to cache\n        this.uriDataCache[id] = res\n        return res\n    }\n}\n\nexport default ERC721Token\n","import axios from 'axios'\n\nlet network_id: number = 0\n\nclass AvaNetwork {\n    name: string\n    id: number\n    protocol: string\n    port: number\n    ip: string\n    networkId: number\n    // chainId: string;\n    url: string\n    explorerUrl: string | undefined\n    explorerSiteUrl: string | undefined\n    readonly: boolean\n    withCredentials = false\n    // fee: BN\n\n    constructor(\n        name: string,\n        url: string,\n        networkId: number,\n        explorerUrl?: string,\n        explorerSiteUrl?: string,\n        readonly = false\n    ) {\n        this.id = network_id++\n        this.name = name\n        this.explorerUrl = explorerUrl\n        this.explorerSiteUrl = explorerSiteUrl\n        this.protocol = 'http'\n        this.port = 9650\n        this.ip = 'localhost'\n        this.url = url\n        this.updateURL(url)\n        this.networkId = networkId\n        // this.chainId = chainId;\n        this.readonly = readonly\n        // this.fee = new BN(0);\n    }\n\n    async testConnection(credentials = false) {\n        let resp = await axios\n            .post(\n                this.url + '/ext/info',\n                {\n                    jsonrpc: '2.0',\n                    id: 1,\n                    method: 'info.getNetworkID',\n                },\n                {\n                    withCredentials: true,\n                }\n            )\n            .catch((err) => {\n                return false\n            })\n\n        return true\n    }\n\n    // Checks if this network endpoint allows credentials\n    async updateCredentials() {\n        try {\n            let res = await axios.post(\n                this.url + '/ext/info',\n                {\n                    jsonrpc: '2.0',\n                    id: 1,\n                    method: 'info.getNetworkID',\n                },\n                {\n                    withCredentials: true,\n                }\n            )\n            this.withCredentials = true\n        } catch (e) {\n            this.withCredentials = false\n        }\n    }\n\n    updateURL(url: string) {\n        let split: string[] = url.split('://')\n\n        this.protocol = split[0]\n\n        // port is set\n        if (split[1].includes(':')) {\n            let urlSplit: string[] = split[1].split(':')\n            let ip: string = urlSplit[0]\n            let port: string = urlSplit[1]\n\n            this.ip = ip\n            this.port = parseInt(port)\n        } else {\n            this.ip = split[1]\n            if (this.protocol === 'http') {\n                this.port = 80\n            } else {\n                this.port = 443\n            }\n        }\n    }\n    getFullURL() {\n        return `${this.protocol}://${this.ip}:${this.port}`\n    }\n\n    getWsUrlX(): string {\n        let protocol = this.protocol === 'https' ? 'wss' : 'ws'\n        return `${protocol}://${this.ip}:${this.port}/ext/bc/X/events`\n    }\n\n    getWsUrlC(): string {\n        let protocol = this.protocol === 'https' ? 'wss' : 'ws'\n        return `${protocol}://${this.ip}:${this.port}/ext/bc/C/ws`\n    }\n}\n\nexport { AvaNetwork }\n","import { TokenListToken } from '@/store/modules/assets/types'\nimport { web3 } from '@/evm'\nimport { BN } from 'avalanche'\nimport { bnToBig } from '@/helpers/helper'\nimport Big from 'big.js'\nimport store from '@/store'\n\nimport ERC20Abi from '@openzeppelin/contracts/build/contracts/ERC20.json'\n\nclass Erc20Token {\n    data: TokenListToken\n    contract: any\n    balanceRaw: string\n    balanceBN: BN\n    balanceBig: Big\n\n    constructor(tokenData: TokenListToken) {\n        this.data = tokenData\n        this.balanceRaw = '0'\n        this.balanceBN = new BN('0')\n        this.balanceBig = Big(0)\n\n        //@ts-ignore\n        var tokenInst = new web3.eth.Contract(ERC20Abi.abi, tokenData.address)\n        this.contract = tokenInst\n    }\n\n    // Returns a new instance of the token, given only the erc20 address\n    static fromAddress(address: string) {\n        //@ts-ignore\n        var tokenInst = new web3.eth.Contract(ERC20Abi.abi, address)\n        console.log(tokenInst)\n    }\n\n    createTransferTx(to: string, amount: BN) {\n        return this.contract.methods.transfer(to, amount.toString())\n    }\n\n    async updateBalance(address: string) {\n        let bal = await this.contract.methods.balanceOf('0x' + address).call()\n        this.balanceRaw = bal\n        this.balanceBN = new BN(bal)\n        this.balanceBig = bnToBig(this.balanceBN, parseInt(this.data.decimals as string))\n    }\n}\n\nexport default Erc20Token\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { BN, Buffer } from 'avalanche'\nimport {\n    AssetAmountDestination,\n    BaseTx,\n    MinterSet,\n    NFTMintOutput,\n    TransferableInput,\n    TransferableOutput,\n    UnsignedTx as AVMUnsignedTx,\n    UTXO as AVMUTXO,\n    UTXOSet,\n    UTXOSet as AVMUTXOSet,\n    AVMConstants,\n} from 'avalanche/dist/apis/avm'\n\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { OutputOwners } from 'avalanche/dist/common'\nimport {\n    UTXOSet as PlatformUTXOSet,\n    UnsignedTx as PlatformUnsignedTx,\n    PlatformVMConstants,\n} from 'avalanche/dist/apis/platformvm'\n\nimport { UnsignedTx as EVMUnsignedTx, EVMConstants } from 'avalanche/dist/apis/evm'\nimport { ChainIdType } from '@/constants'\n\nimport { web3 } from '@/evm'\nimport { AvmExportChainType, WalletType } from '@/js/wallets/types'\nimport ERC721Token from '@/js/ERC721Token'\nimport { Transaction } from '@ethereumjs/tx'\nimport EthereumjsCommon from '@ethereumjs/common'\nimport Erc20Token from '@/js/Erc20Token'\n\nexport async function buildUnsignedTransaction(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    derivedAddresses: string[],\n    utxoset: AVMUTXOSet,\n    changeAddress?: string,\n    memo?: Buffer\n) {\n    // TODO: Get new change index.\n    if (!changeAddress) {\n        throw 'Unable to issue transaction. Ran out of change index.'\n    }\n\n    let fromAddrsStr: string[] = derivedAddresses\n    let fromAddrs: Buffer[] = fromAddrsStr.map((val) => bintools.parseAddress(val, 'X'))\n    let changeAddr: Buffer = bintools.stringToAddress(changeAddress)\n\n    // TODO: use internal asset ID\n    // This does not update on network change, causing issues\n    const DJTX_ID_BUF = await avm.getDJTXAssetID()\n    const DJTX_ID_STR = DJTX_ID_BUF.toString('hex')\n    const TO_BUF = bintools.stringToAddress(addr)\n\n    const aad: AssetAmountDestination = new AssetAmountDestination([TO_BUF], fromAddrs, [\n        changeAddr,\n    ])\n    const ZERO = new BN(0)\n    let isFeeAdded = false\n\n    // Aggregate Fungible ins & outs\n    for (let i: number = 0; i < orders.length; i++) {\n        let order: ITransaction | AVMUTXO = orders[i]\n\n        if ((order as ITransaction).asset) {\n            // if fungible\n            let tx: ITransaction = order as ITransaction\n\n            let assetId = bintools.cb58Decode(tx.asset.id)\n            let amt: BN = tx.amount\n\n            if (assetId.toString('hex') === DJTX_ID_STR) {\n                aad.addAssetAmount(assetId, amt, avm.getTxFee())\n                isFeeAdded = true\n            } else {\n                aad.addAssetAmount(assetId, amt, ZERO)\n            }\n        }\n    }\n\n    // If fee isn't added, add it\n    if (!isFeeAdded) {\n        if (avm.getTxFee().gt(ZERO)) {\n            aad.addAssetAmount(DJTX_ID_BUF, ZERO, avm.getTxFee())\n        }\n    }\n\n    const success: Error = utxoset.getMinimumSpendable(aad)\n\n    let ins: TransferableInput[] = []\n    let outs: TransferableOutput[] = []\n    if (typeof success === 'undefined') {\n        ins = aad.getInputs()\n        outs = aad.getAllOutputs()\n    } else {\n        throw success\n    }\n\n    //@ts-ignore\n    let nftUtxos: UTXO[] = orders.filter((val) => {\n        if ((val as ITransaction).asset) return false\n        return true\n    })\n\n    // If transferring an NFT, build the transaction on top of an NFT tx\n    let unsignedTx: AVMUnsignedTx\n    let networkId: number = ava.getNetworkID()\n    let chainId: Buffer = bintools.cb58Decode(avm.getBlockchainID())\n\n    if (nftUtxos.length > 0) {\n        let nftSet = new AVMUTXOSet()\n        nftSet.addArray(nftUtxos)\n\n        let utxoIds: string[] = nftSet.getUTXOIDs()\n\n        // Sort nft utxos\n        utxoIds.sort((a, b) => {\n            if (a < b) {\n                return -1\n            } else if (a > b) {\n                return 1\n            }\n            return 0\n        })\n\n        unsignedTx = nftSet.buildNFTTransferTx(\n            networkId,\n            chainId,\n            [TO_BUF],\n            fromAddrs,\n            fromAddrs, // change address should be something else?\n            utxoIds,\n            undefined,\n            undefined,\n            memo\n        )\n\n        let rawTx = unsignedTx.getTransaction()\n        let outsNft = rawTx.getOuts()\n        let insNft = rawTx.getIns()\n\n        // TODO: This is a hackish way of doing this, need methods in avalanche.js\n        //@ts-ignore\n        rawTx.outs = outsNft.concat(outs)\n        //@ts-ignore\n        rawTx.ins = insNft.concat(ins)\n    } else {\n        let baseTx: BaseTx = new BaseTx(networkId, chainId, outs, ins, memo)\n        unsignedTx = new AVMUnsignedTx(baseTx)\n    }\n    return unsignedTx\n}\n\nexport async function buildCreateNftFamilyTx(\n    name: string,\n    symbol: string,\n    groupNum: number,\n    fromAddrs: string[],\n    minterAddr: string,\n    changeAddr: string,\n    utxoSet: UTXOSet\n) {\n    let fromAddresses = fromAddrs\n    let changeAddress = changeAddr\n    let minterAddress = minterAddr\n\n    const minterSets: MinterSet[] = []\n\n    // Create the groups\n    for (var i = 0; i < groupNum; i++) {\n        const minterSet: MinterSet = new MinterSet(1, [minterAddress])\n        minterSets.push(minterSet)\n    }\n\n    let unsignedTx: AVMUnsignedTx = await avm.buildCreateNFTAssetTx(\n        utxoSet,\n        fromAddresses,\n        [changeAddress],\n        minterSets,\n        name,\n        symbol\n    )\n    return unsignedTx\n}\n\nexport async function buildMintNftTx(\n    mintUtxo: AVMUTXO,\n    payload: PayloadBase,\n    quantity: number,\n    ownerAddress: string,\n    changeAddress: string,\n    fromAddresses: string[],\n    utxoSet: UTXOSet\n): Promise<AVMUnsignedTx> {\n    let addrBuf = bintools.parseAddress(ownerAddress, 'X')\n    let owners = []\n\n    let sourceAddresses = fromAddresses\n\n    for (var i = 0; i < quantity; i++) {\n        let owner = new OutputOwners([addrBuf])\n        owners.push(owner)\n    }\n\n    let groupID = (mintUtxo.getOutput() as NFTMintOutput).getGroupID()\n\n    let mintTx = await avm.buildCreateNFTMintTx(\n        utxoSet,\n        owners,\n        sourceAddresses,\n        [changeAddress],\n        mintUtxo.getUTXOID(),\n        groupID,\n        payload\n    )\n    return mintTx\n}\n\nexport async function buildAvmExportTransaction(\n    destinationChain: AvmExportChainType,\n    utxoSet: AVMUTXOSet,\n    fromAddresses: string[],\n    toAddress: string,\n    amount: BN, // export amount + fee\n    sourceChangeAddress: string\n) {\n    let destinationChainId\n    switch (destinationChain) {\n        case 'P':\n            destinationChainId = pChain.getBlockchainID()\n            break\n        case 'C':\n            destinationChainId = cChain.getBlockchainID()\n            break\n    }\n\n    return await avm.buildExportTx(\n        utxoSet as AVMUTXOSet,\n        amount,\n        destinationChainId,\n        [toAddress],\n        fromAddresses,\n        [sourceChangeAddress]\n    )\n}\n\nexport async function buildPlatformExportTransaction(\n    utxoSet: PlatformUTXOSet,\n    fromAddresses: string[],\n    toAddress: string,\n    amount: BN, // export amount + fee\n    sourceChangeAddress: string\n) {\n    let destinationChainId = avm.getBlockchainID()\n\n    return await pChain.buildExportTx(\n        utxoSet,\n        amount,\n        destinationChainId,\n        [toAddress],\n        fromAddresses,\n        [sourceChangeAddress]\n    )\n}\n\nexport async function buildEvmExportTransaction(\n    fromAddresses: string[],\n    toAddress: string,\n    amount: BN, // export amount + fee\n    fromAddressBech: string\n) {\n    let destinationChainId = avm.getBlockchainID()\n\n    const nonce = await web3.eth.getTransactionCount(fromAddresses[0])\n    const djtxAssetIDBuf: Buffer = await avm.getDJTXAssetID()\n    const djtxAssetIDStr: string = bintools.cb58Encode(djtxAssetIDBuf)\n\n    let fromAddressHex = fromAddresses[0]\n\n    return await cChain.buildExportTx(\n        amount,\n        djtxAssetIDStr,\n        destinationChainId,\n        fromAddressHex,\n        fromAddressBech,\n        [toAddress],\n        nonce\n    )\n}\n\nexport async function buildEvmTransferNativeTx(\n    from: string,\n    to: string,\n    amount: BN, // in wei\n    gasPrice: BN,\n    gasLimit: number\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    let tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            to: to,\n            value: amount,\n            data: '0x',\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport async function buildEvmTransferErc20Tx(\n    from: string,\n    to: string,\n    amount: BN, // in wei\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    let tokenTx = token.createTransferTx(to, amount)\n\n    let tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            value: '0x0',\n            to: token.data.address,\n            data: tokenTx.encodeABI(),\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport async function buildEvmTransferErc721Tx(\n    from: string,\n    to: string,\n    gasPrice: BN,\n    gasLimit: number,\n    token: ERC721Token,\n    tokenId: string\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    let tokenTx = token.createTransferTx(from, to, tokenId)\n\n    let tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            value: '0x0',\n            to: token.data.address,\n            data: tokenTx.encodeABI(),\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport enum AvmTxNameEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Mint' = AVMConstants.CREATEASSETTX,\n    'Operation' = AVMConstants.OPERATIONTX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum PlatfromTxNameEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n    'Add Subnet Validator' = PlatformVMConstants.ADDSUBNETVALIDATORTX,\n    'Create Chain' = PlatformVMConstants.CREATECHAINTX,\n    'Create Subnet' = PlatformVMConstants.CREATESUBNETTX,\n    'Advance Time' = PlatformVMConstants.ADVANCETIMETX,\n    'Reward Validator' = PlatformVMConstants.REWARDVALIDATORTX,\n}\n\n// TODO: create asset transactions\nexport enum ParseableAvmTxEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum ParseablePlatformEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n}\n\nexport enum ParseableEvmTxEnum {\n    'Import' = EVMConstants.IMPORTTX,\n    'Export' = EVMConstants.EXPORTTX,\n}\n","import { Buffer } from 'buffer/'\nimport createHash from 'create-hash'\n\n/**\n * @ignore\n */\n\n/**\n * Helper utility for encryption and password hashing, browser-safe.\n * Encryption is using AES-GCM with a random public nonce.\n */\nexport default class CryptoHelpers {\n    protected ivSize: number = 12\n\n    protected saltSize: number = 16\n\n    protected tagLength: number = 128\n\n    protected aesLength: number = 256\n\n    public keygenIterations: number = 200000 //3.0, 2.0 uses 100000\n\n    /**\n     * Internal-intended function for cleaning passwords.\n     *\n     * @param password\n     * @param salt\n     */\n    _pwcleaner(password: string, slt: Buffer): Buffer {\n        const pw: Buffer = Buffer.from(password, 'utf8')\n        return this.sha256(Buffer.concat([pw, slt]))\n    }\n    /**\n     * Internal-intended function for producing an intermediate key.\n     *\n     * @param pwkey\n     */\n\n    async _keyMaterial(pwkey: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.importKey(\n            'raw',\n            new Uint8Array(pwkey),\n            { name: 'PBKDF2' },\n            false,\n            ['deriveKey']\n        )\n    }\n\n    /**\n     * Internal-intended function for turning an intermediate key into a salted key.\n     *\n     * @param keyMaterial\n     * @param salt\n     */\n    async _deriveKey(keyMaterial: CryptoKey, salt: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt,\n                iterations: this.keygenIterations,\n                hash: 'SHA-256',\n            },\n            keyMaterial,\n            { name: 'AES-GCM', length: this.aesLength },\n            false,\n            ['encrypt', 'decrypt']\n        )\n    }\n\n    /**\n     * A SHA256 helper function.\n     *\n     * @param message The message to hash\n     *\n     * @returns A {@link https://github.com/feross/buffer|Buffer} containing the SHA256 hash of the message\n     */\n    sha256(message: string | Buffer): Buffer {\n        let buff: Buffer\n        if (typeof message === 'string') {\n            buff = Buffer.from(message, 'utf8')\n        } else {\n            buff = Buffer.from(message)\n        }\n        return Buffer.from(createHash('sha256').update(buff).digest()) // ensures correct Buffer class is used\n    }\n\n    /**\n     * Generates a randomized {@link https://github.com/feross/buffer|Buffer} to be used as a salt\n     */\n    makeSalt(): Buffer {\n        const salt = Buffer.alloc(this.saltSize)\n        window.crypto.getRandomValues(salt)\n        return salt\n    }\n\n    /**\n     * Produces a password-safe hash.\n     *\n     * @param password A string for the password\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} containing a salt used in the password hash\n     *\n     * @returns An object containing the \"salt\" and the \"hash\" produced by this function, both as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async pwhash(password: string, salt: Buffer): Promise<{ salt: Buffer; hash: Buffer }> {\n        let slt: Buffer\n        if (salt instanceof Buffer) {\n            slt = salt\n            // @ts-ignore\n        } else if (salt instanceof Uint8Array && process.env.NODE_ENV === 'test') {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        const hash: Buffer = this._pwcleaner(password, this._pwcleaner(password, slt))\n        return { salt: slt, hash }\n    }\n\n    /**\n     * Encrypts plaintext with the provided password using AES-GCM.\n     *\n     * @param password A string for the password\n     * @param plaintext The plaintext to encrypt\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} for the salt to use in the encryption process\n     *\n     * @returns An object containing the \"salt\", \"iv\", and \"ciphertext\", all as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async encrypt(\n        password: string,\n        plaintext: Buffer | string,\n        salt: Buffer | undefined = undefined\n    ): Promise<{ salt: Buffer; iv: Buffer; ciphertext: Buffer }> {\n        let slt: Buffer\n        if (typeof salt !== 'undefined' && salt instanceof Buffer) {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        let pt: Buffer\n        if (typeof plaintext !== 'undefined' && plaintext instanceof Buffer) {\n            pt = plaintext\n        } else {\n            pt = Buffer.from(plaintext, 'utf8')\n        }\n        const pwkey: Buffer = this._pwcleaner(password, slt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, slt)\n        const iv: Buffer = Buffer.from(window.crypto.getRandomValues(new Uint8Array(this.ivSize)))\n\n        const ciphertext: Buffer = Buffer.from(\n            await window.crypto.subtle.encrypt(\n                {\n                    name: 'AES-GCM',\n                    iv,\n                    additionalData: slt,\n                    tagLength: this.tagLength,\n                },\n                pkey,\n                pt\n            )\n        )\n\n        return {\n            salt: slt,\n            iv,\n            ciphertext,\n        }\n    }\n\n    /**\n     * Decrypts ciphertext with the provided password, iv, and salt.\n     *\n     * @param password A string for the password\n     * @param ciphertext A {@link https://github.com/feross/buffer|Buffer} for the ciphertext\n     * @param salt A {@link https://github.com/feross/buffer|Buffer} for the salt\n     * @param iv A {@link https://github.com/feross/buffer|Buffer} for the iv\n     */\n    async decrypt(password: string, ciphertext: Buffer, salt: Buffer, iv: Buffer): Promise<Buffer> {\n        const pwkey: Buffer = this._pwcleaner(password, salt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, salt)\n\n        const pt: Buffer = Buffer.from(\n            await window.crypto.subtle.decrypt(\n                {\n                    name: 'AES-GCM',\n                    iv, // The initialization vector you used to encrypt\n                    additionalData: salt, // The addtionalData you used to encrypt (if any)\n                    tagLength: 128, // The tagLength you used to encrypt (if any)\n                },\n                pkey, // from generateKey or importKey above\n                ciphertext // ArrayBuffer of the data\n            )\n        )\n        return pt\n    }\n\n    constructor() {}\n}\n","// Functions to manage import/export of keystore files\nimport {\n    AllKeyFileDecryptedTypes,\n    AllKeyFileTypes,\n    KeyFileDecryptedV2,\n    KeyFileDecryptedV3,\n    KeyFileDecryptedV4,\n    KeyFileDecryptedV5,\n    KeyFileDecryptedV6,\n    KeyFileKeyDecryptedV2,\n    KeyFileKeyDecryptedV3,\n    KeyFileKeyDecryptedV4,\n    KeyFileKeyDecryptedV5,\n    KeyFileKeyDecryptedV6,\n    KeyFileKeyV2,\n    KeyFileKeyV3,\n    KeyFileKeyV4,\n    KeyFileKeyV5,\n    KeyFileKeyV6,\n    KeyFileV2,\n    KeyFileV3,\n    KeyFileV4,\n    KeyFileV5,\n    KeyFileV6,\n    KeystoreFileKeyType,\n} from './IKeystore'\nimport { avm, bintools } from '@/AVA'\nimport { Buffer } from 'buffer/'\nimport MnemonicWallet from '@/js/wallets/MnemonicWallet'\nimport Crypto from '@/js/Crypto'\nimport { SingletonWallet } from '@/js/wallets/SingletonWallet'\nimport { AccessWalletMultipleInput } from '@/store/types'\nimport { keyToKeypair } from '@/helpers/helper'\nimport * as bip39 from 'bip39'\n\nconst cryptoHelpers = new Crypto()\n\nconst KEYSTORE_VERSION: string = '6.0'\n\nconst ITERATIONS_V2 = 100000\nconst ITERATIONS_V3 = 200000 // and any version above\n\nconst SUPPORTED_VERSION = ['2.0', '3.0', '4.0', '5.0', '6.0']\n\ninterface IHash {\n    salt: Buffer\n    hash: Buffer\n}\n\ninterface PKCrypt {\n    salt: Buffer\n    iv: Buffer\n    ciphertext: Buffer\n}\n\nasync function readV2(data: KeyFileV2, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V2\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: Buffer = await cryptoHelpers._pwcleaner(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV2[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV2[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV2 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(key_decrypt)\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV3(data: KeyFileV3, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash.hash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV3[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV3[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV3 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(key_decrypt)\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV4(data: KeyFileV4, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash.hash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV4[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV4[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV4 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(key_decrypt)\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV5(data: KeyFileV5, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash.hash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV5[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV5[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV5 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV6(data: KeyFileV6, pass: string): Promise<KeyFileDecryptedV6> {\n    const version: string = data.version\n    const activeIndex = data.activeIndex\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n\n    let keys: KeyFileKeyV6[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV6[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV6 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let type: KeystoreFileKeyType = key_data.type\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer\n        try {\n            key_decrypt = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        } catch (e) {\n            throw 'INVALID_PASS'\n        }\n\n        const key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n            type: type,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: activeIndex || 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readKeyFile(data: AllKeyFileTypes, pass: string): Promise<AllKeyFileDecryptedTypes> {\n    switch (data.version) {\n        case '6.0':\n            return await readV6(data as KeyFileV6, pass)\n        case '5.0':\n            return await readV5(data as KeyFileV5, pass)\n        case '4.0':\n            return await readV4(data as KeyFileV4, pass)\n        case '3.0':\n            return await readV3(data as KeyFileV3, pass)\n        case '2.0':\n            return await readV2(data as KeyFileV2, pass)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\nfunction extractKeysV2(\n    file: KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4\n): AccessWalletMultipleInput[] {\n    let chainID = avm.getBlockchainAlias()\n    let keys = (file as KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4).keys\n\n    return keys.map((key) => {\n        // Private keys from the keystore file do not have the PrivateKey- prefix\n        let pk = 'PrivateKey-' + key.key\n        let keypair = keyToKeypair(pk, chainID)\n\n        let keyBuf = keypair.getPrivateKey()\n        let keyHex: string = keyBuf.toString('hex')\n        let paddedKeyHex = keyHex.padStart(64, '0')\n        let mnemonic: string = bip39.entropyToMnemonic(paddedKeyHex)\n\n        return {\n            key: mnemonic,\n            type: 'mnemonic',\n        }\n    })\n}\n\nfunction extractKeysV5(file: KeyFileDecryptedV5): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        key: key.key,\n        type: 'mnemonic',\n    }))\n}\n\nfunction extractKeysV6(file: KeyFileDecryptedV6): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        type: key.type,\n        key: key.key,\n    }))\n}\n\nfunction extractKeysFromDecryptedFile(file: AllKeyFileDecryptedTypes): AccessWalletMultipleInput[] {\n    switch (file.version) {\n        case '6.0':\n            return extractKeysV6(file as KeyFileDecryptedV6)\n        case '5.0':\n            return extractKeysV5(file as KeyFileDecryptedV5)\n        case '4.0':\n            return extractKeysV2(file as KeyFileDecryptedV4)\n        case '3.0':\n            return extractKeysV2(file as KeyFileDecryptedV3)\n        case '2.0':\n            return extractKeysV2(file as KeyFileDecryptedV2)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\n// Given an array of wallets and a password, return an encrypted JSON object that is the keystore file\nasync function makeKeyfile(\n    wallets: (MnemonicWallet | SingletonWallet)[],\n    pass: string,\n    activeIndex: number\n): Promise<KeyFileV6> {\n    // 3.0 and above uses 200,000\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = await cryptoHelpers.makeSalt()\n\n    let keys: KeyFileKeyV6[] = []\n\n    for (let i: number = 0; i < wallets.length; i++) {\n        let wallet = wallets[i]\n        let key\n        let type: KeystoreFileKeyType\n        if (wallet.type === 'singleton') {\n            key = (wallet as SingletonWallet).key\n            type = 'singleton'\n        } else {\n            key = (wallet as MnemonicWallet).mnemonic\n            type = 'mnemonic'\n        }\n        let pk_crypt: PKCrypt = await cryptoHelpers.encrypt(pass, key, salt)\n\n        let key_data: KeyFileKeyV6 = {\n            key: bintools.cb58Encode(pk_crypt.ciphertext),\n            iv: bintools.cb58Encode(pk_crypt.iv),\n            type: type,\n        }\n        keys.push(key_data)\n    }\n\n    let file_data: KeyFileV6 = {\n        version: KEYSTORE_VERSION,\n        salt: bintools.cb58Encode(salt),\n        activeIndex,\n        keys: keys,\n    }\n    return file_data\n}\n\nexport { readKeyFile, makeKeyfile, KEYSTORE_VERSION, extractKeysFromDecryptedFile }\n","import axios, { AxiosInstance } from 'axios'\nimport { ITransactionData } from './store/modules/history/types'\n\n// Doesn't really matter what we set, it will change\nconst api_url: string = 'localhost'\nconst explorer_api: AxiosInstance = axios.create({\n    baseURL: api_url,\n    withCredentials: false,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n})\n\nasync function getAddressHistory(\n    addrs: string[],\n    limit = 20,\n    chainID: string,\n    endTime?: string\n): Promise<ITransactionData[]> {\n    const ADDR_SIZE = 1024\n    let selection = addrs.slice(0, ADDR_SIZE)\n    let remaining = addrs.slice(ADDR_SIZE)\n\n    let addrsRaw = selection.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    let rootUrl = 'v2/transactions'\n\n    let req = {\n        address: addrsRaw,\n        sort: ['timestamp-desc'],\n        disableCount: ['1'],\n        chainID: [chainID],\n        disableGenesis: ['false'],\n    }\n\n    if (limit > 0) {\n        //@ts-ignore\n        req.limit = [limit.toString()]\n    }\n\n    if (endTime) {\n        console.log('Setting endtime')\n        //@ts-ignore\n        req.endTime = [endTime]\n    }\n\n    let res = await explorer_api.post(rootUrl, req)\n    let txs = res.data.transactions\n    let next: string | undefined = res.data.next\n\n    if (txs === null) txs = []\n\n    // If we need to fetch more for this address\n    if (next && !limit) {\n        let endTime = next.split('&')[0].split('=')[1]\n        let nextRes = await getAddressHistory(selection, limit, chainID, endTime)\n        txs.push(...nextRes)\n    }\n\n    // If there are addresses left, fetch them too\n    if (remaining.length > 0) {\n        let nextRes = await getAddressHistory(remaining, limit, chainID)\n        txs.push(...nextRes)\n    }\n\n    return txs\n}\n\nasync function isAddressUsedX(addr: string) {\n    let addrRaw = addr.split('-')[1]\n    let url = `/x/transactions?address=${addrRaw}&limit=1&disableCount=1`\n    try {\n        let res = await explorer_api.get(url)\n        // console.log(res);\n        if (res.data.transactions.length > 0) return true\n        else return false\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressDetailX(addr: string) {\n    let addrRaw = addr.split('-')[1]\n    let url = `/x/addresses/${addrRaw}`\n\n    try {\n        let res = await explorer_api.get(url)\n        return res.data\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressChains(addrs: string[]) {\n    // Strip the prefix\n    let rawAddrs = addrs.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    let urlRoot = `/v2/addressChains`\n\n    let res = await explorer_api.post(urlRoot, {\n        address: rawAddrs,\n        disableCount: ['1'],\n    })\n\n    return res.data.addressChains\n}\n\nexport { explorer_api, getAddressHistory, getAddressDetailX, isAddressUsedX, getAddressChains }\n","import Web3 from 'web3'\n\nimport ERC721Abi from '@openzeppelin/contracts/build/contracts/ERC721.json'\nimport ERC20Abi from '@openzeppelin/contracts/build/contracts/ERC20.json'\n\nconst abiDecoder = require('abi-decoder') // NodeJS\n\nabiDecoder.addABI(ERC721Abi.abi)\nabiDecoder.addABI(ERC20Abi.abi)\n\nlet rpcUrl = `https://djt.northeurope.cloudapp.azure.com/ext/bc/C/rpc`\n\nlet web3 = new Web3(rpcUrl)\n\nexport { web3, abiDecoder }\n","const axios = require('axios')\n\nconst COIN_ID = 'loopring'\nconst COINGECKO_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=loopring&vs_currencies=usd'\n\nconst coingeckoApi = axios.create({\n    baseURL: 'https://api.coingecko.com/api/v3',\n    timeout: 10000,\n})\n\nexport async function getDjtxPriceUSD(): Promise<number> {\n    let res = await axios.get(COINGECKO_URL)\n    return res.data['loopring']['usd']\n}\n\nlet priceHistory: [number, number][] = []\nasync function getPriceHistory() {\n    let res = await coingeckoApi.get(`/coins/${COIN_ID}/market_chart`, {\n        params: {\n            vs_currency: 'usd',\n            days: 'max',\n            interval: 'daily',\n        },\n    })\n\n    priceHistory = res.data.prices\n}\n\n/**\n * Round the UNIX time in ms and search the previously fetched price points\n * @param time\n */\nexport function getPriceAtUnixTime(time: number): number | undefined {\n    let remainder = time % (24 * 60 * 60 * 1000)\n    let dayTimestamp = time - remainder\n\n    let pricePair = priceHistory.find((value) => {\n        return value[0] == dayTimestamp\n    })\n\n    if (!pricePair) return undefined\n    return pricePair[1]\n}\n\ngetPriceHistory()\n","import {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    UTXOSet as AVMUTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm'\nimport { getPreferredHRP } from 'avalanche/dist/utils'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport HDKey from 'hdkey'\nimport { Buffer } from 'buffer/'\nimport {\n    KeyChain as PlatformVMKeyChain,\n    KeyPair as PlatformVMKeyPair,\n} from 'avalanche/dist/apis/platformvm'\nimport store from '@/store'\n\nimport { getAddressChains } from '@/explorer_api'\nimport { AvaNetwork } from '@/js/AvaNetwork'\nimport { ChainAlias } from './wallets/types'\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from '@/helpers/utxo_helper'\nimport { updateFilterAddresses } from '../providers'\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\n\nconst SCAN_SIZE: number = 100 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\nclass HdHelper {\n    chainId: ChainAlias\n    keyChain: AVMKeyChain | PlatformVMKeyChain\n    keyCache: {\n        [index: number]: AVMKeyPair | PlatformVMKeyPair\n    }\n    addressCache: {\n        [index: number]: string\n    }\n    hdCache: {\n        [index: number]: HDKey\n    }\n    changePath: string\n    masterKey: HDKey\n    hdIndex: number\n    utxoSet: AVMUTXOSet | PlatformUTXOSet\n    isPublic: boolean\n    isFetchUtxo: boolean // true if updating balance\n    isInit: boolean // true if HD index is found\n\n    constructor(\n        changePath: string,\n        masterKey: HDKey,\n        chainId: ChainAlias = 'X',\n        isPublic: boolean = false\n    ) {\n        this.changePath = changePath\n        this.isFetchUtxo = false\n        this.isInit = false\n\n        this.chainId = chainId\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        if (chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n\n        this.keyCache = {}\n        this.addressCache = {}\n        this.hdCache = {}\n        this.masterKey = masterKey\n        this.hdIndex = 0\n        this.isPublic = isPublic\n        // this.oninit()\n    }\n\n    async oninit() {\n        await this.findHdIndex()\n    }\n\n    // When the wallet connects to a different network\n    // Clear internal data and scan again\n    async onNetworkChange() {\n        this.clearCache()\n        this.isInit = false\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        if (this.chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n        this.hdIndex = 0\n        await this.oninit()\n    }\n\n    // Increments the hd index by one and adds the key\n    // returns the new keypair\n    incrementIndex(): number {\n        let newIndex: number = this.hdIndex + 1\n\n        if (!this.isPublic) {\n            if (this.chainId === 'X') {\n                let keychain = this.keyChain as AVMKeyChain\n                let newKey = this.getKeyForIndex(newIndex) as AVMKeyPair\n                keychain.addKey(newKey)\n            } else {\n                let keychain = this.keyChain as PlatformVMKeyChain\n                let newKey = this.getKeyForIndex(newIndex) as PlatformVMKeyPair\n                keychain.addKey(newKey)\n            }\n        }\n\n        this.hdIndex = newIndex\n\n        // Update websocket addresses with the new one\n        updateFilterAddresses()\n\n        return newIndex\n    }\n\n    async findHdIndex() {\n        // Check if explorer is available\n\n        // @ts-ignore\n        let network: AvaNetwork = store.state.Network.selectedNetwork\n        let explorerUrl = network.explorerUrl\n\n        if (explorerUrl) {\n            this.hdIndex = await this.findAvailableIndexExplorer()\n        } else {\n            this.hdIndex = await this.findAvailableIndexNode()\n        }\n\n        if (!this.isPublic) {\n            this.updateKeychain()\n        }\n        this.isInit = true\n    }\n\n    // Fetches the utxos for the current keychain\n    // and increments the index if last index has a utxo\n    async updateUtxos(): Promise<AVMUTXOSet | PlatformUTXOSet> {\n        this.isFetchUtxo = true\n\n        if (!this.isInit) {\n            console.error('HD Index not found yet.')\n        }\n\n        let addrs: string[] = this.getAllDerivedAddresses()\n        let result: AVMUTXOSet | PlatformUTXOSet\n\n        if (this.chainId === 'X') {\n            result = await avmGetAllUTXOs(addrs)\n        } else {\n            result = await platformGetAllUTXOs(addrs)\n        }\n        this.utxoSet = result // we can use local copy of utxos as cache for some functions\n\n        // If the hd index is full, increment\n        let currentAddr = this.getCurrentAddress()\n        let currentAddrBuf = bintools.parseAddress(currentAddr, this.chainId)\n        let currentUtxos = result.getUTXOIDs([currentAddrBuf])\n\n        if (currentUtxos.length > 0) {\n            this.incrementIndex()\n        }\n        this.isFetchUtxo = false\n        return result\n    }\n\n    // Returns more addresses than the current index\n    getExtendedAddresses() {\n        let hdIndex = this.hdIndex\n        return this.getAllDerivedAddresses(hdIndex + INDEX_RANGE)\n    }\n\n    // Not used?\n    getUtxos(): AVMUTXOSet | PlatformUTXOSet {\n        return this.utxoSet\n    }\n\n    // Updates the helper keychain to contain keys upto the HD Index\n    updateKeychain(): AVMKeyChain | PlatformVMKeyChain {\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let keychain: AVMKeyChain | PlatformVMKeyChain\n\n        if (this.chainId === 'X') {\n            keychain = new AVMKeyChain(hrp, this.chainId)\n        } else {\n            keychain = new PlatformVMKeyChain(hrp, this.chainId)\n        }\n\n        for (let i: number = 0; i <= this.hdIndex; i++) {\n            let key: AVMKeyPair | PlatformVMKeyPair\n            if (this.chainId === 'X') {\n                key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(keychain as AVMKeyChain).addKey(key)\n            } else {\n                key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(keychain as PlatformVMKeyChain).addKey(key)\n            }\n        }\n        this.keyChain = keychain\n        return keychain\n    }\n\n    getKeychain() {\n        return this.keyChain\n    }\n\n    // Returns all key pairs up to hd index\n    getAllDerivedKeys(upTo = this.hdIndex): AVMKeyPair[] | PlatformVMKeyPair[] {\n        let set: AVMKeyPair[] | PlatformVMKeyPair[] = []\n        for (var i = 0; i <= upTo; i++) {\n            if (this.chainId === 'X') {\n                let key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(set as AVMKeyPair[]).push(key)\n            } else {\n                let key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(set as PlatformVMKeyPair[]).push(key)\n            }\n        }\n        return set\n    }\n\n    getAllDerivedAddresses(upTo = this.hdIndex, start = 0): string[] {\n        let res = []\n        for (var i = start; i <= upTo; i++) {\n            let addr = this.getAddressForIndex(i)\n            res.push(addr)\n        }\n        return res\n    }\n\n    clearCache() {\n        this.keyCache = {}\n        this.addressCache = {}\n    }\n\n    // Scans the address space of this hd path and finds the last used index using the\n    // explorer API.\n    async findAvailableIndexExplorer(startIndex = 0): Promise<number> {\n        let upTo = 512\n\n        let addrs = this.getAllDerivedAddresses(startIndex + upTo, startIndex)\n        let addrChains = await getAddressChains(addrs)\n\n        let chainID\n        if (this.chainId === 'X') {\n            chainID = avm.getBlockchainID()\n        } else {\n            chainID = pChain.getBlockchainID()\n        }\n\n        for (var i = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n\n            for (var n = 0; n < INDEX_RANGE; n++) {\n                let scanIndex = i + n\n                let scanAddr = addrs[scanIndex]\n\n                let rawAddr = scanAddr.split('-')[1]\n                let chains: string[] = addrChains[rawAddr]\n\n                if (!chains) {\n                    // If doesnt exist on any chain\n                    gapSize++\n                } else if (!chains.includes(chainID)) {\n                    // If doesnt exist on this chain\n                    gapSize++\n                } else {\n                    i = i + n\n                    break\n                }\n            }\n\n            // If the gap is reached return the index\n            if (gapSize === INDEX_RANGE) {\n                return startIndex + i\n            }\n        }\n\n        return await this.findAvailableIndexExplorer(startIndex + (upTo - INDEX_RANGE))\n    }\n\n    // Uses the node to find last used HD index\n    // Only used when there is no explorer API available\n    async findAvailableIndexNode(start: number = 0): Promise<number> {\n        let addrs: string[] = []\n\n        // Get keys for indexes start to start+scan_size\n        for (let i: number = start; i < start + SCAN_SIZE; i++) {\n            let address = this.getAddressForIndex(i)\n            addrs.push(address)\n        }\n\n        let utxoSet\n\n        if (this.chainId === 'X') {\n            utxoSet = (await avm.getUTXOs(addrs)).utxos\n        } else {\n            utxoSet = (await pChain.getUTXOs(addrs)).utxos\n        }\n\n        // Scan UTXOs of these indexes and try to find a gap of INDEX_RANGE\n        for (let i: number = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n            // console.log(`Scan index: ${this.chainId} ${this.changePath}/${i+start}`);\n            for (let n: number = 0; n < INDEX_RANGE; n++) {\n                let scanIndex: number = i + n\n                let addr: string = addrs[scanIndex]\n                let addrBuf = bintools.parseAddress(addr, this.chainId)\n                let addrUTXOs: string[] = utxoSet.getUTXOIDs([addrBuf])\n                if (addrUTXOs.length === 0) {\n                    gapSize++\n                } else {\n                    // Potential improvement\n                    i = i + n\n                    break\n                }\n            }\n\n            // If we found a gap of 20, we can return the last fullIndex+1\n            if (gapSize === INDEX_RANGE) {\n                let targetIndex = start + i\n                return targetIndex\n            }\n        }\n        return await this.findAvailableIndexNode(start + SCAN_RANGE)\n    }\n\n    getFirstAvailableIndex(): number {\n        for (var i = 0; i < this.hdIndex; i++) {\n            let addr = this.getAddressForIndex(i)\n            let addrBuf = bintools.parseAddress(addr, this.chainId)\n            let utxoIds = this.utxoSet.getUTXOIDs([addrBuf])\n            if (utxoIds.length === 0) {\n                return i\n            }\n        }\n\n        return 0\n    }\n\n    // Returns the key of the first index that has no utxos\n    getFirstAvailableAddress(): string {\n        const idx = this.getFirstAvailableIndex()\n        return this.getAddressForIndex(idx)\n    }\n\n    getCurrentKey(): AVMKeyPair | PlatformVMKeyPair {\n        let index: number = this.hdIndex\n        return this.getKeyForIndex(index)\n    }\n\n    getCurrentAddress(): string {\n        let index = this.hdIndex\n        return this.getAddressForIndex(index)\n    }\n\n    // TODO: Public wallet should never be using this\n    getKeyForIndex(index: number, isPrivate: boolean = true): AVMKeyPair | PlatformVMKeyPair {\n        // If key is cached return that\n        let cacheExternal: AVMKeyPair | PlatformVMKeyPair\n\n        if (this.chainId === 'X') {\n            cacheExternal = this.keyCache[index] as AVMKeyPair\n        } else {\n            cacheExternal = this.keyCache[index] as PlatformVMKeyPair\n        }\n\n        if (cacheExternal) return cacheExternal\n\n        let derivationPath: string = `${this.changePath}/${index.toString()}`\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        let pkHex: string\n        if (!this.isPublic) {\n            pkHex = key.privateKey.toString('hex')\n        } else {\n            pkHex = key.publicKey.toString('hex')\n        }\n\n        let pkBuf: Buffer = new Buffer(pkHex, 'hex')\n        let keypair = this.keyChain.importKey(pkBuf)\n\n        // save to cache\n        this.keyCache[index] = keypair\n        return keypair\n    }\n\n    getAddressForIndex(index: number): string {\n        if (this.addressCache[index]) {\n            return this.addressCache[index]\n        }\n\n        let derivationPath: string = `${this.changePath}/${index.toString()}`\n        // let key: HDKey = this.masterKey.derive(derivationPath) as HDKey;\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        let pkHex = key.publicKey.toString('hex')\n        let pkBuff = Buffer.from(pkHex, 'hex')\n        let hrp = getPreferredHRP(ava.getNetworkID())\n\n        let chainId = this.chainId\n\n        // No need for PlatformKeypair because addressToString uses chainID to decode\n        let keypair = new AVMKeyPair(hrp, chainId)\n        let addrBuf = keypair.addressFromPublicKey(pkBuff)\n        let addr = bintools.addressToString(hrp, chainId, addrBuf)\n\n        this.addressCache[index] = addr\n        return addr\n    }\n\n    // Given an address find the derived index\n    findAddressIndex(addr: string): number | null {\n        let addrs = this.getAllDerivedAddresses()\n        let index = addrs.indexOf(addr)\n\n        if (index < 0) return null\n        return index\n    }\n}\nexport { HdHelper }\n","import { ChainAlias } from '@/js/wallets/types'\nimport { UTXO } from 'avalanche/dist/apis/avm'\n\nimport { BN, Buffer } from 'avalanche'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { ava, avm, bintools, pChain } from '@/AVA'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport HDKey from 'hdkey'\nimport { HdHelper } from '@/js/HdHelper'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport { buildCreateNftFamilyTx, buildMintNftTx, buildUnsignedTransaction } from '../TxHelper'\nimport { WalletCore } from '@/js/wallets/WalletCore'\nimport { updateFilterAddresses } from '../../providers'\nimport { digestMessage } from '@/helpers/helper'\n\n// A base class other HD wallets are based on.\n// Mnemonic Wallet and LedgerWallet uses this\n\nabstract class HdWalletCore extends WalletCore {\n    chainId: string\n\n    internalHelper: HdHelper\n    externalHelper: HdHelper\n    platformHelper: HdHelper\n\n    constructor(accountHdKey: HDKey, isPublic = true) {\n        super()\n\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.externalHelper = new HdHelper('m/0', accountHdKey, undefined, isPublic)\n        this.internalHelper = new HdHelper('m/1', accountHdKey, undefined, isPublic)\n        this.platformHelper = new HdHelper('m/0', accountHdKey, 'P', isPublic)\n\n        this.externalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.internalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.platformHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n    }\n\n    getUTXOSet(): AVMUTXOSet {\n        return this.utxoset\n    }\n\n    updateAvmUTXOSet(): void {\n        // if (this.isFetchUtxos) return\n        let setExternal = this.externalHelper.utxoSet as AVMUTXOSet\n        let setInternal = this.internalHelper.utxoSet as AVMUTXOSet\n\n        let joined = setInternal.merge(setExternal)\n        this.utxoset = joined\n    }\n\n    getFirstAvailableAddressPlatform(): string {\n        return this.platformHelper.getFirstAvailableAddress()\n    }\n\n    updateFetchState() {\n        this.isFetchUtxos =\n            this.externalHelper.isFetchUtxo ||\n            this.internalHelper.isFetchUtxo ||\n            this.platformHelper.isFetchUtxo\n    }\n\n    updateInitState() {\n        this.isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n\n        if (this.isInit) {\n            updateFilterAddresses()\n        }\n    }\n    // Fetches the utxos\n    async getUTXOs(): Promise<void> {\n        this.updateUTXOsX()\n\n        // platform utxos are updated but not returned by function\n        this.updateUTXOsP()\n\n        return\n    }\n\n    async updateUTXOsX() {\n        this.updateUTXOsExternal()\n        this.updateUTXOsInternal()\n    }\n\n    async updateUTXOsExternal() {\n        let res = await this.externalHelper.updateUtxos()\n        this.updateFetchState()\n        this.updateAvmUTXOSet()\n    }\n\n    async updateUTXOsInternal() {\n        let utxoSet = await this.internalHelper.updateUtxos()\n        this.updateFetchState()\n        this.updateAvmUTXOSet()\n    }\n\n    async updateUTXOsP() {\n        let utxoSet = await this.platformHelper.updateUtxos()\n        this.updateFetchState()\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.externalHelper.getAllDerivedAddresses()\n    }\n\n    getDerivedAddresses(): string[] {\n        let internal = this.internalHelper.getAllDerivedAddresses()\n        let external = this.externalHelper.getAllDerivedAddresses()\n        return internal.concat(external)\n    }\n\n    getDerivedAddressesP(): string[] {\n        return this.platformHelper.getAllDerivedAddresses()\n    }\n\n    getAllAddressesX() {\n        return this.getDerivedAddresses()\n    }\n\n    getAllAddressesP() {\n        return this.getDerivedAddressesP()\n    }\n    // Returns addresses to check for history\n    getHistoryAddresses(): string[] {\n        let internalIndex = this.internalHelper.hdIndex\n        // They share the same address space, so whatever has the highest index\n        let externalIndex = Math.max(this.externalHelper.hdIndex, this.platformHelper.hdIndex)\n\n        let internal = this.internalHelper.getAllDerivedAddresses(internalIndex)\n        let external = this.externalHelper.getAllDerivedAddresses(externalIndex)\n        return internal.concat(external)\n    }\n\n    getCurrentAddressAvm(): string {\n        return this.externalHelper.getCurrentAddress()\n    }\n\n    getChangeAddressAvm() {\n        return this.internalHelper.getCurrentAddress()\n    }\n\n    getChangeAddressPlatform() {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getChangePath(chainId?: ChainAlias): string {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.changePath\n            case 'X':\n            default:\n                return this.internalHelper.changePath\n        }\n    }\n\n    getChangeIndex(chainId?: ChainAlias): number {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.hdIndex\n            case 'X':\n            default:\n                return this.internalHelper.hdIndex\n        }\n    }\n\n    getChangeFromIndex(idx?: number, chainId?: ChainAlias): string | null {\n        if (idx === undefined || idx === null) return null\n\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.getAddressForIndex(idx)\n            case 'X':\n            default:\n                return this.internalHelper.getAddressForIndex(idx)\n        }\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getCurrentAddressPlatform(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getPlatformUTXOSet() {\n        return this.platformHelper.utxoSet as PlatformUTXOSet\n    }\n\n    getPlatformActiveIndex() {\n        return this.platformHelper.hdIndex\n    }\n\n    getExternalActiveIndex() {\n        return this.externalHelper.hdIndex\n    }\n\n    getBaseAddress() {\n        return this.externalHelper.getAddressForIndex(0)\n    }\n\n    onnetworkchange(): void {\n        this.isInit = false\n        this.stakeAmount = new BN(0)\n\n        this.externalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.internalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.platformHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n\n        // TODO: Handle EVM changes\n    }\n\n    async buildUnsignedTransaction(orders: (ITransaction | UTXO)[], addr: string, memo?: Buffer) {\n        const changeAddress = this.getChangeAddressAvm()\n        const derivedAddresses: string[] = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet()\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n\n    findExternalAddressIndex(address: string): number | null {\n        // TODO: Look for P addresses too\n        let indexX = this.externalHelper.findAddressIndex(address)\n        let indexP = this.platformHelper.findAddressIndex(address)\n\n        let index = indexX !== null ? indexX : indexP\n\n        if (indexX === null && indexP === null) throw new Error('Address not found.')\n        return index\n    }\n\n    async signMessageByExternalAddress(msgStr: string, address: string) {\n        let index = this.findExternalAddressIndex(address)\n        if (index === null) throw new Error('Address not found.')\n        return await this.signMessageByExternalIndex(msgStr, index)\n    }\n\n    async signMessageByExternalIndex(msgStr: string, index: number): Promise<string> {\n        let digest = digestMessage(msgStr)\n\n        // Convert to the other Buffer and sign\n        let digestHex = digest.toString('hex')\n        let digestBuff = Buffer.from(digestHex, 'hex')\n\n        return await this.signHashByExternalIndex(index, digestBuff)\n    }\n\n    async signMessage(msg: string, address: string) {\n        return await this.signMessageByExternalAddress(msg, address)\n    }\n\n    abstract async signHashByExternalIndex(index: number, hash: Buffer): Promise<string>\n}\nexport { HdWalletCore }\n","// interface IHistoryParsedBaseTx{\n//     sent:\n//     received:\n// }\n\nimport { ITransactionData, UTXO } from '@/store/modules/history/types'\nimport { WalletType } from '@/js/wallets/types'\nimport { BN } from 'avalanche'\nimport { AVMConstants } from 'avalanche/dist/apis/avm'\n\n// Summary item returned for each transaction\nexport interface BaseTxSummary {\n    tokens: {\n        [assetId: string]: BaseTxAssetSummary\n    }\n    collectibles: BaseTxNFTSummary\n}\n\ninterface TokenSummaryResult {\n    [assetID: string]: BaseTxAssetSummary\n}\n\nexport interface BaseTxNFTSummary {\n    received: NFTSummaryResultDict\n    sent: NFTSummaryResultDict\n}\n\ninterface NFTSummaryResultDict {\n    assets: {\n        [assetID: string]: UTXO[]\n    }\n    addresses: string[]\n}\n\n// export interface BaseTxNFTSummary {\n//     sent: UTXO[]\n//     received: UTXO[]\n// }\n\nexport interface BaseTxAssetSummary {\n    amount: BN\n    payload: string | undefined\n    groupNum: number\n    addresses: string[]\n}\n\n// Used with tokens\nfunction addToDict(\n    assetId: string,\n    amount: BN,\n    dict: TokenSummaryResult,\n    utxo: UTXO,\n    addresses: string[]\n) {\n    if (dict[assetId]) {\n        dict[assetId].amount = dict[assetId].amount.add(amount)\n\n        let addrDiff = addresses.filter((addr) => !dict[assetId].addresses.includes(addr))\n        dict[assetId].addresses.push(...addrDiff)\n    } else {\n        dict[assetId] = {\n            amount: amount,\n            payload: utxo.payload,\n            groupNum: utxo.groupID,\n            addresses: addresses,\n        }\n    }\n}\n\nfunction getNFTsSummary(tx: ITransactionData, wallet: WalletType): BaseTxNFTSummary {\n    let nftLoss = getLossNFT(tx, wallet)\n    let nftGain = getGainNFT(tx, wallet)\n    return {\n        sent: nftLoss,\n        received: nftGain,\n    }\n}\n\nfunction getLossNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let inputs = tx.inputs || []\n    let outputs = tx.outputs\n\n    let loss: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    let nfts = inputs.filter((input) => {\n        let type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    let nftsOuts = outputs.filter((output) => {\n        let type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (var i = 0; i < nfts.length; i++) {\n        let utxo = nfts[i].output\n        let owners = utxo.addresses\n        let assetID = utxo.assetID\n\n        let intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we lose it?\n        if (intersect.length > 0) {\n            if (loss.assets[assetID]) {\n                loss.assets[assetID].push(utxo)\n            } else {\n                loss.assets[assetID] = [utxo]\n            }\n\n            // Who did we lose it to?\n            for (var n = 0; i < nftsOuts.length; n++) {\n                let nftOut = nftsOuts[n]\n                let doesMatch = nftOut.groupID === utxo.groupID && nftOut.assetID === utxo.assetID\n                let addrNotAdded = nftOut.addresses.filter((addr) => !loss.addresses.includes(addr))\n                if (doesMatch) {\n                    loss.addresses.push(...addrNotAdded)\n                    break\n                }\n            }\n        }\n    }\n\n    return loss\n}\n\nfunction getGainNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let inputs = tx.inputs || []\n    let outputs = tx.outputs\n\n    let gain: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    let nftsIns = inputs.filter((input) => {\n        let type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    let nftsOuts = outputs.filter((output) => {\n        let type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (var i = 0; i < nftsOuts.length; i++) {\n        let utxo = nftsOuts[i]\n        let owners = utxo.addresses\n        let assetID = utxo.assetID\n\n        let intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we gain it?\n        if (intersect.length > 0) {\n            if (gain.assets[assetID]) {\n                gain.assets[assetID].push(utxo)\n            } else {\n                gain.assets[assetID] = [utxo]\n            }\n\n            // Who did we gain it from?\n            for (var n = 0; n < nftsIns.length; n++) {\n                let nftIn = nftsIns[n].output\n                let doesMatch = nftIn.groupID === utxo.groupID && nftIn.assetID === utxo.assetID\n                let addrNotAdded = nftIn.addresses.filter((addr) => !gain.addresses.includes(addr))\n                if (doesMatch) {\n                    gain.addresses.push(...addrNotAdded)\n                }\n            }\n        }\n    }\n\n    return gain\n}\n\nfunction getLoss(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    let ins = tx.inputs || []\n    let outs = tx.outputs\n\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let loss: TokenSummaryResult = {}\n\n    if (ins) {\n        for (let i = 0; i < ins.length; i++) {\n            let input = ins[i]\n            let utxo = input.output\n            let outputType = utxo.outputType\n            let isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            if (isNft) continue\n\n            let addrs = utxo.addresses\n\n            let intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            let assetId = utxo.assetID\n            let amount = utxo.amount\n            let amountBN = new BN(amount)\n\n            // Get who received this asset\n            let receivers: string[] = []\n            outs.forEach((utxo) => {\n                if (utxo.assetID === assetId) {\n                    let outAddrs = utxo.addresses\n                    // If not a wallet address and not added to receivers\n                    let targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !receivers.includes(addr)\n                    )\n                    receivers.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, loss, utxo, receivers)\n        }\n    }\n\n    return loss\n}\n\nfunction getProfit(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    let outs = tx.outputs\n    let ins = tx.inputs || []\n\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let profit: TokenSummaryResult = {}\n\n    if (outs) {\n        for (let i = 0; i < outs.length; i++) {\n            let utxo = outs[i]\n            let outputType = utxo.outputType\n            let isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            // Skip NFTs\n            if (isNft) continue\n\n            let addrs = utxo.addresses\n\n            let intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            let assetId = utxo.assetID\n            let amount = utxo.amount\n            let amountBN = new BN(amount)\n\n            // Get who sent this to you\n            let senders: string[] = []\n            ins.forEach((input) => {\n                let utxo = input.output\n                if (utxo.assetID === assetId) {\n                    let outAddrs = utxo.addresses\n                    // If not a wallet address and not added to senders\n                    let targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !senders.includes(addr)\n                    )\n                    senders.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, profit, utxo, senders)\n        }\n    }\n\n    return profit\n}\n\n// Finds the absolute gains and losses for the active wallet given transaction data from the explorer\nfunction getTransactionSummary(tx: ITransactionData, wallet: WalletType) {\n    let losses = getLoss(tx, wallet)\n    let profits = getProfit(tx, wallet)\n\n    let nftSummary = getNFTsSummary(tx, wallet)\n\n    // let nftLoss = getLossNFT(tx, wallet)\n    // let nftGain = getGainNFT()NFT(tx, wallet)\n    // console.log(nftLoss)\n\n    let sum: BaseTxSummary = {\n        tokens: {},\n        collectibles: {\n            sent: nftSummary.sent,\n            received: nftSummary.received,\n        },\n    }\n\n    // First the losses\n    for (let assetId in losses) {\n        let loss = losses[assetId]\n\n        sum.tokens[assetId] = {\n            amount: loss.amount.mul(new BN(-1)),\n            payload: loss.payload,\n            groupNum: loss.groupNum,\n            addresses: loss.addresses,\n        }\n    }\n\n    for (let assetId in profits) {\n        let profit = profits[assetId]\n\n        if (sum.tokens[assetId]) {\n            sum.tokens[assetId].amount = sum.tokens[assetId].amount.add(profit.amount)\n        } else {\n            sum.tokens[assetId] = {\n                amount: profit.amount,\n                payload: profit.payload,\n                groupNum: profit.groupNum,\n                addresses: profit.addresses,\n            }\n        }\n    }\n\n    return sum\n}\n\n/**\n * Given an array of transactions from the explorer, filter out duplicate transactions\n * @param txs\n */\nexport function filterDuplicateTransactions(txs: ITransactionData[]) {\n    let txsIds: string[] = []\n    let filtered: ITransactionData[] = []\n\n    for (var i = 0; i < txs.length; i++) {\n        let tx = txs[i]\n        let txId = tx.id\n\n        if (txsIds.includes(txId)) {\n            continue\n        } else {\n            txsIds.push(txId)\n            filtered.push(tx)\n        }\n    }\n    return filtered\n}\n\nexport { getTransactionSummary }\n","// import AppBtc from \"@ledgerhq/hw-app-btc\";\n//@ts-ignore\nimport AppDjtx from '@obsidiansystems/hw-app-avalanche'\n//@ts-ignore\nimport Eth from '@ledgerhq/hw-app-eth'\n\nimport EthereumjsCommon from '@ethereumjs/common'\nimport { Transaction } from '@ethereumjs/tx'\n\nimport moment from 'moment'\nimport { Buffer, BN } from 'avalanche'\nimport HDKey from 'hdkey'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nconst bippath = require('bip32-path')\nimport createHash from 'create-hash'\nimport store from '@/store'\nimport { importPublic, publicToAddress, bnToRlp, rlp } from 'ethereumjs-util'\n\nimport { UTXO as AVMUTXO, UTXO, UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport {\n    AvaWalletCore,\n    AvmExportChainType,\n    AvmImportChainType,\n    ChainAlias,\n} from '@/js/wallets/types'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport {\n    AVMConstants,\n    OperationTx,\n    SelectCredentialClass as AVMSelectCredentialClass,\n    TransferableOperation,\n    TransferableOutput as AVMTransferableOutput,\n    Tx as AVMTx,\n    UnsignedTx as AVMUnsignedTx,\n    ImportTx as AVMImportTx,\n    ExportTx as AVMExportTx,\n} from 'avalanche/dist/apis/avm'\n\nimport {\n    ImportTx as PlatformImportTx,\n    ExportTx,\n    TransferableOutput as PlatformTransferableOutput,\n    Tx as PlatformTx,\n    UTXO as PlatformUTXO,\n    UnsignedTx as PlatformUnsignedTx,\n    UTXOSet as PlatformUTXOSet,\n    PlatformVMConstants,\n    SelectCredentialClass as PlatformSelectCredentialClass,\n    AddDelegatorTx,\n    AddValidatorTx,\n} from 'avalanche/dist/apis/platformvm'\n\nimport {\n    UTXOSet as EVMUTXOSet,\n    UnsignedTx as EVMUnsignedTx,\n    ImportTx as EVMImportTx,\n    ExportTx as EVMExportTx,\n    Tx as EvmTx,\n    EVMConstants,\n    EVMInput,\n    SelectCredentialClass as EVMSelectCredentialClass,\n} from 'avalanche/dist/apis/evm'\n\nimport { Credential, SigIdx, Signature, UTXOResponse, Address } from 'avalanche/dist/common'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { ILedgerAppConfig } from '@/store/types'\nimport { WalletNameType } from '@/js/wallets/types'\nimport { bnToBig, digestMessage } from '@/helpers/helper'\nimport { abiDecoder, web3 } from '@/evm'\nimport { AVA_ACCOUNT_PATH, ETH_ACCOUNT_PATH, LEDGER_ETH_ACCOUNT_PATH } from './MnemonicWallet'\nimport { ChainIdType } from '@/constants'\nimport { ParseableAvmTxEnum, ParseablePlatformEnum, ParseableEvmTxEnum } from '../TxHelper'\nimport { ILedgerBlockMessage } from '../../store/modules/ledger/types'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletHelper } from '@/helpers/wallet_helper'\n\nexport const MIN_EVM_SUPPORT_V = '0.5.3'\n\nclass LedgerWallet extends HdWalletCore implements AvaWalletCore {\n    app: AppDjtx\n    ethApp: Eth\n    type: WalletNameType\n\n    ethAddress: string\n    ethBalance: BN\n    ethAddressBech: string\n    config: ILedgerAppConfig\n\n    constructor(app: AppDjtx, hdkey: HDKey, config: ILedgerAppConfig, hdEth?: HDKey, ethApp?: Eth) {\n        super(hdkey)\n        this.app = app\n        this.ethApp = ethApp\n        this.type = 'ledger'\n        this.config = config\n\n        if (hdEth) {\n            const ethKey = hdEth\n            const ethPublic = importPublic(ethKey.publicKey)\n            this.ethAddress = publicToAddress(ethPublic).toString('hex')\n            this.ethBalance = new BN(0)\n            this.ethAddressBech = bintools.addressToString(\n                ava.getHRP(),\n                'C',\n                // @ts-ignore\n                hdEth.pubKeyHash\n            )\n        } else {\n            this.ethAddress = ''\n            this.ethAddressBech = ''\n            this.ethBalance = new BN(0)\n        }\n    }\n\n    static async fromApp(app: AppDjtx, eth: Eth, config: ILedgerAppConfig) {\n        let res = await app.getWalletExtendedPublicKey(AVA_ACCOUNT_PATH)\n\n        let hd = new HDKey()\n        hd.publicKey = res.public_key\n        hd.chainCode = res.chain_code\n\n        let ethRes = await eth.getAddress(LEDGER_ETH_ACCOUNT_PATH, true, true)\n        let hdEth = new HDKey()\n        // @ts-ignore\n        hdEth.publicKey = Buffer.from(ethRes.publicKey, 'hex')\n        // @ts-ignore\n        hdEth.chainCode = Buffer.from(ethRes.chainCode, 'hex')\n\n        return new LedgerWallet(app, hd, config, hdEth, eth)\n    }\n\n    // Returns an array of derivation paths that need to sign this transaction\n    // Used with signTransactionHash and signTransactionParsable\n    getTransactionPaths<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): { paths: string[]; isDjtxOnly: boolean } {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        let ins = tx.getIns()\n        let operations: TransferableOperation[] = []\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.log(e)\n        }\n\n        let items = ins\n        if (\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P')\n        ) {\n            items = ((tx as AVMImportTx) || PlatformImportTx).getImportInputs()\n        }\n\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let paths: string[] = []\n\n        let isDjtxOnly = true\n        // Collect paths derivation paths for source addresses\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i]\n\n            let assetId = bintools.cb58Encode(item.getAssetID())\n            // @ts-ignore\n            if (assetId !== store.state.Assets.AVA_ASSET_ID) {\n                isDjtxOnly = false\n            }\n\n            let sigidxs: SigIdx[] = item.getInput().getSigIdxs()\n            let sources = sigidxs.map((sigidx) => sigidx.getSource())\n            let addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                let srcAddr = addrs[j]\n                let pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        // Do the Same for operational inputs, if there are any...\n        for (let i = 0; i < operations.length; i++) {\n            let op = operations[i]\n            let sigidxs: SigIdx[] = op.getOperation().getSigIdxs()\n            let sources = sigidxs.map((sigidx) => sigidx.getSource())\n            let addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                let srcAddr = addrs[j]\n                let pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        return { paths, isDjtxOnly }\n    }\n\n    pathsToUniqueBipPaths(paths: string[]) {\n        let uniquePaths = paths.filter((val: any, i: number) => {\n            return paths.indexOf(val) === i\n        })\n\n        let bip32Paths = uniquePaths.map((path) => {\n            return bippath.fromString(path, false)\n        })\n\n        return bip32Paths\n    }\n\n    getChangeBipPath<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ) {\n        if (chainId === 'C') {\n            return null\n        }\n\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        const chainChangePath = this.getChangePath(chainId).split('m/')[1]\n        let changeIdx = this.getChangeIndex(chainId)\n        // If change and destination paths are the same\n        // it can cause ledger to not display the destination amt.\n        // Since platform helper does not have internal/external\n        // path for change (it uses the next address)\n        // there can be an address collisions.\n        if (\n            (txType === PlatformVMConstants.IMPORTTX || txType === PlatformVMConstants.EXPORTTX) &&\n            this.platformHelper.hdIndex === this.externalHelper.hdIndex\n        ) {\n            return null\n        } else if (\n            txType === PlatformVMConstants.ADDVALIDATORTX ||\n            txType === PlatformVMConstants.ADDDELEGATORTX\n        ) {\n            changeIdx = this.platformHelper.getFirstAvailableIndex()\n        }\n\n        return bippath.fromString(`${AVA_ACCOUNT_PATH}/${chainChangePath}/${changeIdx}`)\n    }\n\n    getCredentials<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        paths: string[],\n        sigMap: any,\n        chainId: ChainIdType\n    ): Credential[] {\n        let creds: Credential[] = []\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        // @ts-ignore\n        let ins = tx.getIns ? tx.getIns() : []\n        let operations: TransferableOperation[] = []\n        let evmInputs: EVMInput[] = []\n\n        let items = ins\n        if (\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P') ||\n            (txType === EVMConstants.IMPORTTX && chainId === 'C')\n        ) {\n            items = ((tx as AVMImportTx) || PlatformImportTx || EVMImportTx).getImportInputs()\n        }\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.error(e)\n        }\n\n        let CredentialClass\n        if (chainId === 'X') {\n            CredentialClass = AVMSelectCredentialClass\n        } else if (chainId === 'P') {\n            CredentialClass = PlatformSelectCredentialClass\n        } else {\n            CredentialClass = EVMSelectCredentialClass\n        }\n\n        // Try to get evm inputs, it will fail if there are none, ignore and continue\n        try {\n            evmInputs = (tx as EVMExportTx).getInputs()\n        } catch (e) {\n            console.error(e)\n        }\n\n        for (let i = 0; i < items.length; i++) {\n            const sigidxs: SigIdx[] = items[i].getInput().getSigIdxs()\n            const cred: Credential = CredentialClass(items[i].getInput().getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        for (let i = 0; i < operations.length; i++) {\n            let op = operations[i].getOperation()\n            const sigidxs: SigIdx[] = op.getSigIdxs()\n            const cred: Credential = CredentialClass(op.getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = items.length + i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        for (let i = 0; i < evmInputs.length; i++) {\n            let evmInput = evmInputs[i]\n            const sigidxs: SigIdx[] = evmInput.getSigIdxs()\n            const cred: Credential = CredentialClass(evmInput.getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = items.length + i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        return creds\n    }\n\n    // Used for non parsable transactions.\n    // Ideally we wont use this function at all, but ledger is not ready yet.\n    async signTransactionHash<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx | EvmTx\n    >(unsignedTx: UnsignedTx, paths: string[], chainId: ChainIdType): Promise<SignedTx> {\n        let txbuff = unsignedTx.toBuffer()\n        const msg: Buffer = Buffer.from(createHash('sha256').update(txbuff).digest())\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: 'Sign Hash',\n                messages: [],\n                info: msg.toString('hex').toUpperCase(),\n            })\n\n            let bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n            // Sign the msg with ledger\n            const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n            let sigMap = await this.app.signHash(accountPath, bip32Paths, msg)\n            store.commit('Ledger/closeModal')\n\n            let creds: Credential[] = this.getCredentials<UnsignedTx>(\n                unsignedTx,\n                paths,\n                sigMap,\n                chainId\n            )\n\n            let signedTx\n            switch (chainId) {\n                case 'X':\n                    signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds)\n                    break\n                case 'P':\n                    signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds)\n                    break\n                case 'C':\n                    signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds)\n                    break\n            }\n\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    // Used for signing transactions that are parsable\n    async signTransactionParsable<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx | EvmTx\n    >(unsignedTx: UnsignedTx, paths: string[], chainId: ChainIdType): Promise<SignedTx> {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let parseableTxs = {\n            X: ParseableAvmTxEnum,\n            P: ParseablePlatformEnum,\n            C: ParseableEvmTxEnum,\n        }[chainId]\n\n        let title = `Sign ${parseableTxs[txType]}`\n\n        let bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n        const accountPath =\n            chainId === 'C'\n                ? bippath.fromString(`${ETH_ACCOUNT_PATH}`)\n                : bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n        let txbuff = unsignedTx.toBuffer()\n        let changePath = this.getChangeBipPath(unsignedTx, chainId)\n        let messages = this.getTransactionMessages<UnsignedTx>(unsignedTx, chainId, changePath)\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: title,\n                messages: messages,\n                info: null,\n            })\n\n            let ledgerSignedTx = await this.app.signTransaction(\n                accountPath,\n                bip32Paths,\n                txbuff,\n                changePath\n            )\n\n            let sigMap = ledgerSignedTx.signatures\n            let creds = this.getCredentials<UnsignedTx>(unsignedTx, paths, sigMap, chainId)\n\n            let signedTx\n            switch (chainId) {\n                case 'X':\n                    signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds)\n                    break\n                case 'P':\n                    signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds)\n                    break\n                case 'C':\n                    signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds)\n                    break\n            }\n\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    getOutputMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        let messages: ILedgerBlockMessage[] = []\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        // @ts-ignore\n        let outs\n        if (\n            (txType === AVMConstants.EXPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.EXPORTTX && chainId === 'P')\n        ) {\n            outs = (tx as ExportTx).getExportOutputs()\n        } else if (txType === EVMConstants.EXPORTTX && chainId === 'C') {\n            outs = (tx as EVMExportTx).getExportedOutputs()\n        } else {\n            outs = (tx as ExportTx).getOuts()\n        }\n\n        let destinationChain = chainId\n        if (chainId === 'C' && txType === EVMConstants.EXPORTTX) destinationChain = 'X'\n\n        if (destinationChain === 'C') {\n            for (let i = 0; i < outs.length; i++) {\n                // @ts-ignore\n                const value = outs[i].getAddress()\n                const addr = bintools.addressToString(hrp, chainId, value)\n                // @ts-ignore\n                const amt = bnToBig(outs[i].getAmount(), 9)\n\n                messages.push({\n                    title: 'Output',\n                    value: `${addr} - ${amt.toString()} DJTX`,\n                })\n            }\n        } else {\n            let changeIdx = changePath?.toPathArray()[changePath?.toPathArray().length - 1]\n            let changeAddr = this.getChangeFromIndex(changeIdx, destinationChain)\n\n            for (let i = 0; i < outs.length; i++) {\n                outs[i]\n                    .getOutput()\n                    .getAddresses()\n                    .forEach((value) => {\n                        const addr = bintools.addressToString(hrp, chainId, value)\n                        // @ts-ignore\n                        const amt = bnToBig(outs[i].getOutput().getAmount(), 9)\n\n                        if (!changePath || changeAddr !== addr)\n                            messages.push({\n                                title: 'Output',\n                                value: `${addr} - ${amt.toString()} DJTX`,\n                            })\n                    })\n            }\n        }\n\n        return messages\n    }\n\n    getValidateDelegateMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): ILedgerBlockMessage[] {\n        let tx =\n            ((unsignedTx as\n                | AVMUnsignedTx\n                | PlatformUnsignedTx).getTransaction() as AddValidatorTx) || AddDelegatorTx\n        let txType = tx.getTxType()\n        let messages: ILedgerBlockMessage[] = []\n\n        if (\n            (txType === PlatformVMConstants.ADDDELEGATORTX && chainId === 'P') ||\n            (txType === PlatformVMConstants.ADDVALIDATORTX && chainId === 'P')\n        ) {\n            const format = 'YYYY-MM-DD H:mm:ss UTC'\n\n            const nodeID = bintools.cb58Encode(tx.getNodeID())\n            const startTime = moment(tx.getStartTime().toNumber() * 1000)\n                .utc()\n                .format(format)\n\n            const endTime = moment(tx.getEndTime().toNumber() * 1000)\n                .utc()\n                .format(format)\n\n            const stakeAmt = bnToBig(tx.getStakeAmount(), 9)\n\n            const rewardOwners = tx.getRewardOwners()\n            let hrp = ava.getHRP()\n            const rewardAddrs = rewardOwners\n                .getOutput()\n                .getAddresses()\n                .map((addr) => {\n                    return bintools.addressToString(hrp, chainId, addr)\n                })\n\n            messages.push({ title: 'NodeID', value: nodeID })\n            messages.push({ title: 'Start Time', value: startTime })\n            messages.push({ title: 'End Time', value: endTime })\n            messages.push({ title: 'Total Stake', value: `${stakeAmt} DJTX` })\n            messages.push({\n                title: 'Stake',\n                value: `${stakeAmt} to ${this.platformHelper.getCurrentAddress()}`,\n            })\n            messages.push({\n                title: 'Reward to',\n                value: `${rewardAddrs.join('\\n')}`,\n            })\n            // @ts-ignore\n            if (tx.delegationFee) {\n                // @ts-ignore\n                messages.push({ title: 'Delegation Fee', value: `${tx.delegationFee}%` })\n            }\n            messages.push({ title: 'Fee', value: '0' })\n        }\n\n        return messages\n    }\n\n    getFeeMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): ILedgerBlockMessage[] {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let messages = []\n\n        if (\n            (txType === AVMConstants.BASETX && chainId === 'X') ||\n            (txType === AVMConstants.EXPORTTX && chainId === 'X') ||\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.EXPORTTX && chainId === 'P') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P') ||\n            (txType === EVMConstants.EXPORTTX && chainId === 'C') ||\n            (txType === EVMConstants.IMPORTTX && chainId === 'C')\n        ) {\n            messages.push({ title: 'Fee', value: `${0.001} DJTX` })\n        }\n\n        return messages\n    }\n\n    // Given the unsigned transaction returns an array of messages that will be displayed on ledgegr window\n    getTransactionMessages<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        let messages: ILedgerBlockMessage[] = []\n\n        const outputMessages = this.getOutputMsgs(unsignedTx, chainId, changePath)\n        messages.push(...outputMessages)\n\n        const validateDelegateMessages = this.getValidateDelegateMsgs(\n            unsignedTx as AVMUnsignedTx | PlatformUnsignedTx,\n            chainId\n        )\n        messages.push(...validateDelegateMessages)\n\n        const feeMessages = this.getFeeMsgs(unsignedTx, chainId)\n        messages.push(...feeMessages)\n\n        return messages\n    }\n\n    getEvmTransactionMessages(tx: Transaction): ILedgerBlockMessage[] {\n        let gasPrice = tx.gasPrice\n        let gasLimit = tx.gasLimit\n        let totFee = gasPrice.mul(new BN(gasLimit))\n        let feeNano = bnToBig(totFee, 9)\n\n        let msgs: ILedgerBlockMessage[] = []\n        try {\n            let test = '0x' + tx.data.toString('hex')\n            let data = abiDecoder.decodeMethod(test)\n\n            let callMsg: ILedgerBlockMessage = {\n                title: 'Contract Call',\n                value: data.name,\n            }\n            let paramMsgs: ILedgerBlockMessage[] = data.params.map((param: any) => {\n                return {\n                    title: param.name,\n                    value: param.value,\n                }\n            })\n\n            let feeMsg: ILedgerBlockMessage = {\n                title: 'Fee',\n                value: feeNano.toLocaleString() + ' nDJTX',\n            }\n\n            msgs = [callMsg, ...paramMsgs, feeMsg]\n        } catch (e) {\n            console.log(e)\n        }\n        return msgs\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let chainId: ChainIdType = 'X'\n\n        let parseableTxs = ParseableAvmTxEnum\n        let { paths, isDjtxOnly } = this.getTransactionPaths<AVMUnsignedTx>(unsignedTx, chainId)\n\n        // If ledger doesnt support parsing, sign hash\n        let canLedgerParse = this.config.version >= '0.3.1'\n        let isParsableType = txType in parseableTxs && isDjtxOnly\n\n        let signedTx\n        if (canLedgerParse && isParsableType) {\n            signedTx = await this.signTransactionParsable<AVMUnsignedTx, AVMTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        } else {\n            signedTx = await this.signTransactionHash<AVMUnsignedTx, AVMTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        }\n\n        store.commit('Ledger/closeModal')\n        return signedTx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let chainId: ChainIdType = 'P'\n        let parseableTxs = ParseablePlatformEnum\n\n        let { paths, isDjtxOnly } = this.getTransactionPaths<PlatformUnsignedTx>(\n            unsignedTx,\n            chainId\n        )\n        // If ledger doesnt support parsing, sign hash\n        let canLedgerParse = this.config.version >= '0.3.1'\n        let isParsableType = txType in parseableTxs && isDjtxOnly\n\n        // TODO: Remove after ledger is fixed\n        // If UTXOS contain lockedStakeable funds always use sign hash\n        let txIns = unsignedTx.getTransaction().getIns()\n        for (var i = 0; i < txIns.length; i++) {\n            let typeID = txIns[i].getInput().getTypeID()\n            if (typeID === PlatformVMConstants.STAKEABLELOCKINID) {\n                canLedgerParse = false\n                break\n            }\n        }\n\n        let signedTx\n        if (canLedgerParse && isParsableType) {\n            signedTx = await this.signTransactionParsable<PlatformUnsignedTx, PlatformTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        } else {\n            signedTx = await this.signTransactionHash<PlatformUnsignedTx, PlatformTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        }\n        store.commit('Ledger/closeModal')\n        return signedTx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        // TODO: Might need to upgrade paths array to:\n        //  paths = Array(utxoSet.getAllUTXOs().length).fill('0/0'),\n        let tx = unsignedTx.getTransaction()\n        let typeId = tx.getTxType()\n\n        let paths = ['0/0']\n        if (typeId === EVMConstants.EXPORTTX) {\n            let ins = (tx as EVMExportTx).getInputs()\n            paths = ins.map((input) => '0/0')\n        } else if (typeId === EVMConstants.IMPORTTX) {\n            let ins = (tx as EVMImportTx).getImportInputs()\n            paths = ins.map((input) => '0/0')\n        }\n\n        let txSigned = (await this.signTransactionParsable(unsignedTx, paths, 'C')) as EvmTx\n        store.commit('Ledger/closeModal')\n        return txSigned\n    }\n\n    async signEvm(tx: Transaction) {\n        const rawUnsignedTx = rlp.encode([\n            bnToRlp(tx.nonce),\n            bnToRlp(tx.gasPrice),\n            bnToRlp(tx.gasLimit),\n            tx.to !== undefined ? tx.to.buf : Buffer.from([]),\n            bnToRlp(tx.value),\n            tx.data,\n            bnToRlp(new BN(tx.getChainId())),\n            Buffer.from([]),\n            Buffer.from([]),\n        ])\n\n        try {\n            let msgs = this.getEvmTransactionMessages(tx)\n\n            // Open Modal Prompt\n            store.commit('Ledger/openModal', {\n                title: 'Transfer',\n                messages: msgs,\n                info: null,\n            })\n            const signature = await this.ethApp.signTransaction(\n                LEDGER_ETH_ACCOUNT_PATH,\n                rawUnsignedTx\n            )\n            store.commit('Ledger/closeModal')\n\n            const signatureBN = {\n                v: new BN(signature.v, 16),\n                r: new BN(signature.r, 16),\n                s: new BN(signature.s, 16),\n            }\n\n            const chainId = await web3.eth.getChainId()\n            const networkId = await web3.eth.net.getId()\n            const chainParams = {\n                common: EthereumjsCommon.forCustomChain(\n                    'mainnet',\n                    { networkId, chainId },\n                    'istanbul'\n                ),\n            }\n\n            const signedTx = Transaction.fromTxData(\n                {\n                    nonce: tx.nonce,\n                    gasPrice: tx.gasPrice,\n                    gasLimit: tx.gasLimit,\n                    to: tx.to,\n                    value: tx.value,\n                    data: tx.data,\n                    ...signatureBN,\n                },\n                chainParams\n            )\n            return signedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    getEvmAddressBech(): string {\n        return this.ethAddressBech\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    async getEthBalance() {\n        let bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        let isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            // console.info('HD Not ready try again in 1 sec..')\n            return\n        }\n\n        super.getUTXOs()\n        this.getStake()\n        this.getEthBalance()\n        return\n    }\n\n    getPathFromAddress(address: string) {\n        let externalAddrs = this.externalHelper.getExtendedAddresses()\n        let internalAddrs = this.internalHelper.getExtendedAddresses()\n        let platformAddrs = this.platformHelper.getExtendedAddresses()\n\n        let extIndex = externalAddrs.indexOf(address)\n        let intIndex = internalAddrs.indexOf(address)\n        let platformIndex = platformAddrs.indexOf(address)\n\n        if (extIndex >= 0) {\n            return `0/${extIndex}`\n        } else if (intIndex >= 0) {\n            return `1/${intIndex}`\n        } else if (platformIndex >= 0) {\n            return `0/${platformIndex}`\n        } else if (address[0] === 'C') {\n            return '0/0'\n        } else {\n            throw 'Unable to find source address.'\n        }\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    async exportFromPChain(amt: BN) {\n        return await WalletHelper.exportFromPChain(this, amt)\n    }\n\n    async exportFromXChain(amt: BN, destinationChain: AvmExportChainType) {\n        return await WalletHelper.exportFromXChain(this, amt, destinationChain)\n    }\n\n    async exportFromCChain(amt: BN) {\n        return await WalletHelper.exportFromCChain(this, amt)\n    }\n\n    async importToPlatformChain(): Promise<string> {\n        return await WalletHelper.importToPlatformChain(this)\n    }\n\n    async importToXChain(sourceChain: AvmImportChainType): Promise<string> {\n        return await WalletHelper.importToXChain(this, sourceChain)\n    }\n\n    async importToCChain(): Promise<string> {\n        return await WalletHelper.importToCChain(this)\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    async signHashByExternalIndex(index: number, hash: Buffer) {\n        let pathStr = `0/${index}`\n        const addressPath = bippath.fromString(pathStr, false)\n        const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n\n        store.commit('Ledger/openModal', {\n            title: `Sign Hash`,\n            info: hash.toString('hex').toUpperCase(),\n        })\n\n        try {\n            let sigMap = await this.app.signHash(accountPath, [addressPath], hash)\n            store.commit('Ledger/closeModal')\n            let signed = sigMap.get(pathStr)\n            return bintools.cb58Encode(signed)\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            throw e\n        }\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        // throw 'Not Implemented'\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n}\n\nexport { LedgerWallet }\n","var isoLangs = {\n    ab: {\n        name: 'Abkhaz',\n        nativeName: 'аҧсуа',\n    },\n    aa: {\n        name: 'Afar',\n        nativeName: 'Afaraf',\n    },\n    af: {\n        name: 'Afrikaans',\n        nativeName: 'Afrikaans',\n    },\n    ak: {\n        name: 'Akan',\n        nativeName: 'Akan',\n    },\n    sq: {\n        name: 'Albanian',\n        nativeName: 'Shqip',\n    },\n    am: {\n        name: 'Amharic',\n        nativeName: 'አማርኛ',\n    },\n    ar: {\n        name: 'Arabic',\n        nativeName: 'العربية',\n    },\n    an: {\n        name: 'Aragonese',\n        nativeName: 'Aragonés',\n    },\n    hy: {\n        name: 'Armenian',\n        nativeName: 'Հայերեն',\n    },\n    as: {\n        name: 'Assamese',\n        nativeName: 'অসমীয়া',\n    },\n    av: {\n        name: 'Avaric',\n        nativeName: 'авар мацӀ, магӀарул мацӀ',\n    },\n    ae: {\n        name: 'Avestan',\n        nativeName: 'avesta',\n    },\n    ay: {\n        name: 'Aymara',\n        nativeName: 'aymar aru',\n    },\n    az: {\n        name: 'Azerbaijani',\n        nativeName: 'azərbaycan dili',\n    },\n    bm: {\n        name: 'Bambara',\n        nativeName: 'bamanankan',\n    },\n    ba: {\n        name: 'Bashkir',\n        nativeName: 'башҡорт теле',\n    },\n    eu: {\n        name: 'Basque',\n        nativeName: 'euskara, euskera',\n    },\n    be: {\n        name: 'Belarusian',\n        nativeName: 'Беларуская',\n    },\n    bn: {\n        name: 'Bengali',\n        nativeName: 'বাংলা',\n    },\n    bh: {\n        name: 'Bihari',\n        nativeName: 'भोजपुरी',\n    },\n    bi: {\n        name: 'Bislama',\n        nativeName: 'Bislama',\n    },\n    bs: {\n        name: 'Bosnian',\n        nativeName: 'bosanski jezik',\n    },\n    br: {\n        name: 'Breton',\n        nativeName: 'brezhoneg',\n    },\n    bg: {\n        name: 'Bulgarian',\n        nativeName: 'български език',\n    },\n    my: {\n        name: 'Burmese',\n        nativeName: 'ဗမာစာ',\n    },\n    ca: {\n        name: 'Catalan; Valencian',\n        nativeName: 'Català',\n    },\n    ch: {\n        name: 'Chamorro',\n        nativeName: 'Chamoru',\n    },\n    ce: {\n        name: 'Chechen',\n        nativeName: 'нохчийн мотт',\n    },\n    ny: {\n        name: 'Chichewa; Chewa; Nyanja',\n        nativeName: 'chiCheŵa, chinyanja',\n    },\n    cn: {\n        name: 'Chinese',\n        nativeName: '中文 (Zhōngwén), 汉语, 漢語',\n    },\n    zh_hans: {\n        name: 'Chinese (Simplified)',\n        nativeName: '汉语',\n    },\n    zh_hant: {\n        name: 'Chinese (Traditional)',\n        nativeName: '漢語',\n    },\n    cv: {\n        name: 'Chuvash',\n        nativeName: 'чӑваш чӗлхи',\n    },\n    kw: {\n        name: 'Cornish',\n        nativeName: 'Kernewek',\n    },\n    co: {\n        name: 'Corsican',\n        nativeName: 'corsu, lingua corsa',\n    },\n    cr: {\n        name: 'Cree',\n        nativeName: 'ᓀᐦᐃᔭᐍᐏᐣ',\n    },\n    hr: {\n        name: 'Croatian',\n        nativeName: 'hrvatski',\n    },\n    cs: {\n        name: 'Czech',\n        nativeName: 'česky, čeština',\n    },\n    da: {\n        name: 'Danish',\n        nativeName: 'dansk',\n    },\n    dv: {\n        name: 'Divehi; Dhivehi; Maldivian;',\n        nativeName: 'ދިވެހި',\n    },\n    nl: {\n        name: 'Dutch',\n        nativeName: 'Nederlands, Vlaams',\n    },\n    en: {\n        name: 'English',\n        nativeName: 'English',\n    },\n    eo: {\n        name: 'Esperanto',\n        nativeName: 'Esperanto',\n    },\n    et: {\n        name: 'Estonian',\n        nativeName: 'eesti, eesti keel',\n    },\n    ee: {\n        name: 'Ewe',\n        nativeName: 'Eʋegbe',\n    },\n    fo: {\n        name: 'Faroese',\n        nativeName: 'føroyskt',\n    },\n    fj: {\n        name: 'Fijian',\n        nativeName: 'vosa Vakaviti',\n    },\n    fi: {\n        name: 'Finnish',\n        nativeName: 'suomi, suomen kieli',\n    },\n    fr: {\n        name: 'French',\n        nativeName: 'Français',\n    },\n    ff: {\n        name: 'Fula; Fulah; Pulaar; Pular',\n        nativeName: 'Fulfulde, Pulaar, Pular',\n    },\n    gl: {\n        name: 'Galician',\n        nativeName: 'Galego',\n    },\n    ka: {\n        name: 'Georgian',\n        nativeName: 'ქართული',\n    },\n    de: {\n        name: 'German',\n        nativeName: 'Deutsch',\n    },\n    el: {\n        name: 'Greek, Modern',\n        nativeName: 'Ελληνικά',\n    },\n    gn: {\n        name: 'Guaraní',\n        nativeName: 'Avañeẽ',\n    },\n    gu: {\n        name: 'Gujarati',\n        nativeName: 'ગુજરાતી',\n    },\n    ht: {\n        name: 'Haitian; Haitian Creole',\n        nativeName: 'Kreyòl ayisyen',\n    },\n    ha: {\n        name: 'Hausa',\n        nativeName: 'Hausa, هَوُسَ',\n    },\n    he: {\n        name: 'Hebrew (modern)',\n        nativeName: 'עברית',\n    },\n    hz: {\n        name: 'Herero',\n        nativeName: 'Otjiherero',\n    },\n    hi: {\n        name: 'Hindi',\n        nativeName: 'हिन्दी, हिंदी',\n    },\n    ho: {\n        name: 'Hiri Motu',\n        nativeName: 'Hiri Motu',\n    },\n    hu: {\n        name: 'Hungarian',\n        nativeName: 'Magyar',\n    },\n    ia: {\n        name: 'Interlingua',\n        nativeName: 'Interlingua',\n    },\n    id: {\n        name: 'Indonesian',\n        nativeName: 'Bahasa Indonesia',\n    },\n    ie: {\n        name: 'Interlingue',\n        nativeName: 'Originally called Occidental; then Interlingue after WWII',\n    },\n    ga: {\n        name: 'Irish',\n        nativeName: 'Gaeilge',\n    },\n    ig: {\n        name: 'Igbo',\n        nativeName: 'Asụsụ Igbo',\n    },\n    ik: {\n        name: 'Inupiaq',\n        nativeName: 'Iñupiaq, Iñupiatun',\n    },\n    io: {\n        name: 'Ido',\n        nativeName: 'Ido',\n    },\n    is: {\n        name: 'Icelandic',\n        nativeName: 'Íslenska',\n    },\n    it: {\n        name: 'Italian',\n        nativeName: 'Italiano',\n    },\n    iu: {\n        name: 'Inuktitut',\n        nativeName: 'ᐃᓄᒃᑎᑐᑦ',\n    },\n    ja: {\n        name: 'Japanese',\n        nativeName: '日本語',\n    },\n    jv: {\n        name: 'Javanese',\n        nativeName: 'basa Jawa',\n    },\n    kl: {\n        name: 'Kalaallisut, Greenlandic',\n        nativeName: 'kalaallisut, kalaallit oqaasii',\n    },\n    kn: {\n        name: 'Kannada',\n        nativeName: 'ಕನ್ನಡ',\n    },\n    // \"kr\": {\n    //     \"name\": \"Kanuri\",\n    //     \"nativeName\": \"Kanuri\"\n    // },\n    ks: {\n        name: 'Kashmiri',\n        nativeName: 'कश्मीरी, كشميري‎',\n    },\n    kk: {\n        name: 'Kazakh',\n        nativeName: 'Қазақ тілі',\n    },\n    km: {\n        name: 'Khmer',\n        nativeName: 'ភាសាខ្មែរ',\n    },\n    ki: {\n        name: 'Kikuyu, Gikuyu',\n        nativeName: 'Gĩkũyũ',\n    },\n    rw: {\n        name: 'Kinyarwanda',\n        nativeName: 'Ikinyarwanda',\n    },\n    ky: {\n        name: 'Kirghiz, Kyrgyz',\n        nativeName: 'кыргыз тили',\n    },\n    kv: {\n        name: 'Komi',\n        nativeName: 'коми кыв',\n    },\n    kg: {\n        name: 'Kongo',\n        nativeName: 'KiKongo',\n    },\n    kr: {\n        name: 'Korean',\n        nativeName: '한국어',\n    },\n    ku: {\n        name: 'Kurdish',\n        nativeName: 'Kurdî, كوردی‎',\n    },\n    kj: {\n        name: 'Kwanyama, Kuanyama',\n        nativeName: 'Kuanyama',\n    },\n    la: {\n        name: 'Latin',\n        nativeName: 'latine, lingua latina',\n    },\n    lb: {\n        name: 'Luxembourgish, Letzeburgesch',\n        nativeName: 'Lëtzebuergesch',\n    },\n    lg: {\n        name: 'Luganda',\n        nativeName: 'Luganda',\n    },\n    li: {\n        name: 'Limburgish, Limburgan, Limburger',\n        nativeName: 'Limburgs',\n    },\n    ln: {\n        name: 'Lingala',\n        nativeName: 'Lingála',\n    },\n    lo: {\n        name: 'Lao',\n        nativeName: 'ພາສາລາວ',\n    },\n    lt: {\n        name: 'Lithuanian',\n        nativeName: 'lietuvių kalba',\n    },\n    lu: {\n        name: 'Luba-Katanga',\n        nativeName: '',\n    },\n    lv: {\n        name: 'Latvian',\n        nativeName: 'latviešu valoda',\n    },\n    gv: {\n        name: 'Manx',\n        nativeName: 'Gaelg, Gailck',\n    },\n    mk: {\n        name: 'Macedonian',\n        nativeName: 'македонски јазик',\n    },\n    mg: {\n        name: 'Malagasy',\n        nativeName: 'Malagasy fiteny',\n    },\n    ms: {\n        name: 'Malay',\n        nativeName: 'bahasa Melayu, بهاس ملايو‎',\n    },\n    ml: {\n        name: 'Malayalam',\n        nativeName: 'മലയാളം',\n    },\n    mt: {\n        name: 'Maltese',\n        nativeName: 'Malti',\n    },\n    mi: {\n        name: 'Māori',\n        nativeName: 'te reo Māori',\n    },\n    mr: {\n        name: 'Marathi (Marāṭhī)',\n        nativeName: 'मराठी',\n    },\n    mh: {\n        name: 'Marshallese',\n        nativeName: 'Kajin M̧ajeļ',\n    },\n    mn: {\n        name: 'Mongolian',\n        nativeName: 'монгол',\n    },\n    na: {\n        name: 'Nauru',\n        nativeName: 'Ekakairũ Naoero',\n    },\n    nv: {\n        name: 'Navajo, Navaho',\n        nativeName: 'Diné bizaad, Dinékʼehǰí',\n    },\n    nb: {\n        name: 'Norwegian Bokmål',\n        nativeName: 'Norsk bokmål',\n    },\n    nd: {\n        name: 'North Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    ne: {\n        name: 'Nepali',\n        nativeName: 'नेपाली',\n    },\n    ng: {\n        name: 'Ndonga',\n        nativeName: 'Owambo',\n    },\n    nn: {\n        name: 'Norwegian Nynorsk',\n        nativeName: 'Norsk nynorsk',\n    },\n    no: {\n        name: 'Norwegian',\n        nativeName: 'Norsk',\n    },\n    ii: {\n        name: 'Nuosu',\n        nativeName: 'ꆈꌠ꒿ Nuosuhxop',\n    },\n    nr: {\n        name: 'South Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    oc: {\n        name: 'Occitan',\n        nativeName: 'Occitan',\n    },\n    oj: {\n        name: 'Ojibwe, Ojibwa',\n        nativeName: 'ᐊᓂᔑᓈᐯᒧᐎᓐ',\n    },\n    cu: {\n        name: 'Old Church Slavonic, Church Slavic, Church Slavonic, Old Bulgarian, Old Slavonic',\n        nativeName: 'ѩзыкъ словѣньскъ',\n    },\n    om: {\n        name: 'Oromo',\n        nativeName: 'Afaan Oromoo',\n    },\n    or: {\n        name: 'Oriya',\n        nativeName: 'ଓଡ଼ିଆ',\n    },\n    os: {\n        name: 'Ossetian, Ossetic',\n        nativeName: 'ирон æвзаг',\n    },\n    pa: {\n        name: 'Panjabi, Punjabi',\n        nativeName: 'ਪੰਜਾਬੀ, پنجابی‎',\n    },\n    pi: {\n        name: 'Pāli',\n        nativeName: 'पाऴि',\n    },\n    fa: {\n        name: 'Persian',\n        nativeName: 'فارسی',\n    },\n    pl: {\n        name: 'Polish',\n        nativeName: 'polski',\n    },\n    ps: {\n        name: 'Pashto, Pushto',\n        nativeName: 'پښتو',\n    },\n    pt: {\n        name: 'Portuguese',\n        nativeName: 'Português',\n    },\n    qu: {\n        name: 'Quechua',\n        nativeName: 'Runa Simi, Kichwa',\n    },\n    rm: {\n        name: 'Romansh',\n        nativeName: 'rumantsch grischun',\n    },\n    rn: {\n        name: 'Kirundi',\n        nativeName: 'kiRundi',\n    },\n    ro: {\n        name: 'Romanian, Moldavian, Moldovan',\n        nativeName: 'română',\n    },\n    ru: {\n        name: 'Russian',\n        nativeName: 'русский язык',\n    },\n    sa: {\n        name: 'Sanskrit (Saṁskṛta)',\n        nativeName: 'संस्कृतम्',\n    },\n    sc: {\n        name: 'Sardinian',\n        nativeName: 'sardu',\n    },\n    sd: {\n        name: 'Sindhi',\n        nativeName: 'सिन्धी, سنڌي، سندھی‎',\n    },\n    se: {\n        name: 'Northern Sami',\n        nativeName: 'Davvisámegiella',\n    },\n    sm: {\n        name: 'Samoan',\n        nativeName: 'gagana faa Samoa',\n    },\n    sg: {\n        name: 'Sango',\n        nativeName: 'yângâ tî sängö',\n    },\n    sr: {\n        name: 'Serbian',\n        nativeName: 'српски језик',\n    },\n    gd: {\n        name: 'Scottish Gaelic; Gaelic',\n        nativeName: 'Gàidhlig',\n    },\n    sn: {\n        name: 'Shona',\n        nativeName: 'chiShona',\n    },\n    si: {\n        name: 'Sinhala, Sinhalese',\n        nativeName: 'සිංහල',\n    },\n    sk: {\n        name: 'Slovak',\n        nativeName: 'slovenčina',\n    },\n    sl: {\n        name: 'Slovene',\n        nativeName: 'slovenščina',\n    },\n    so: {\n        name: 'Somali',\n        nativeName: 'Soomaaliga, af Soomaali',\n    },\n    st: {\n        name: 'Southern Sotho',\n        nativeName: 'Sesotho',\n    },\n    es: {\n        name: 'Spanish; Castilian',\n        nativeName: 'Español',\n    },\n    su: {\n        name: 'Sundanese',\n        nativeName: 'Basa Sunda',\n    },\n    sw: {\n        name: 'Swahili',\n        nativeName: 'Kiswahili',\n    },\n    ss: {\n        name: 'Swati',\n        nativeName: 'SiSwati',\n    },\n    sv: {\n        name: 'Swedish',\n        nativeName: 'svenska',\n    },\n    ta: {\n        name: 'Tamil',\n        nativeName: 'தமிழ்',\n    },\n    te: {\n        name: 'Telugu',\n        nativeName: 'తెలుగు',\n    },\n    tg: {\n        name: 'Tajik',\n        nativeName: 'тоҷикӣ, toğikī, تاجیکی‎',\n    },\n    th: {\n        name: 'Thai',\n        nativeName: 'ไทย',\n    },\n    ti: {\n        name: 'Tigrinya',\n        nativeName: 'ትግርኛ',\n    },\n    bo: {\n        name: 'Tibetan Standard, Tibetan, Central',\n        nativeName: 'བོད་ཡིག',\n    },\n    tk: {\n        name: 'Turkmen',\n        nativeName: 'Türkmen, Түркмен',\n    },\n    tl: {\n        name: 'Tagalog',\n        nativeName: 'Wikang Tagalog, ᜏᜒᜃᜅ᜔ ᜆᜄᜎᜓᜄ᜔',\n    },\n    tn: {\n        name: 'Tswana',\n        nativeName: 'Setswana',\n    },\n    to: {\n        name: 'Tonga (Tonga Islands)',\n        nativeName: 'faka Tonga',\n    },\n    tr: {\n        name: 'Turkish',\n        nativeName: 'Türkçe',\n    },\n    ts: {\n        name: 'Tsonga',\n        nativeName: 'Xitsonga',\n    },\n    tt: {\n        name: 'Tatar',\n        nativeName: 'татарча, tatarça, تاتارچا‎',\n    },\n    tw: {\n        name: 'Twi',\n        nativeName: 'Twi',\n    },\n    ty: {\n        name: 'Tahitian',\n        nativeName: 'Reo Tahiti',\n    },\n    ug: {\n        name: 'Uighur, Uyghur',\n        nativeName: 'Uyƣurqə, ئۇيغۇرچە‎',\n    },\n    uk: {\n        name: 'Ukrainian',\n        nativeName: 'українська',\n    },\n    ur: {\n        name: 'Urdu',\n        nativeName: 'اردو',\n    },\n    uz: {\n        name: 'Uzbek',\n        nativeName: 'zbek, Ўзбек, أۇزبېك‎',\n    },\n    ve: {\n        name: 'Venda',\n        nativeName: 'Tshivenḓa',\n    },\n    vn: {\n        name: 'Vietnamese',\n        nativeName: 'Tiếng Việt',\n    },\n    vo: {\n        name: 'Volapük',\n        nativeName: 'Volapük',\n    },\n    wa: {\n        name: 'Walloon',\n        nativeName: 'Walon',\n    },\n    cy: {\n        name: 'Welsh',\n        nativeName: 'Cymraeg',\n    },\n    wo: {\n        name: 'Wolof',\n        nativeName: 'Wollof',\n    },\n    fy: {\n        name: 'Western Frisian',\n        nativeName: 'Frysk',\n    },\n    xh: {\n        name: 'Xhosa',\n        nativeName: 'isiXhosa',\n    },\n    yi: {\n        name: 'Yiddish',\n        nativeName: 'ייִדיש',\n    },\n    yo: {\n        name: 'Yoruba',\n        nativeName: 'Yorùbá',\n    },\n    za: {\n        name: 'Zhuang, Chuang',\n        nativeName: 'Saɯ cueŋƅ, Saw cuengh',\n    },\n}\n\nexport default isoLangs\n","import { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport { avm, cChain, pChain } from '@/AVA'\nimport { BN } from 'avalanche'\n\nexport async function getStakeForAddresses(addrs: string[]): Promise<BN> {\n    if (addrs.length <= 256) {\n        let stakeData = await pChain.getStake(addrs)\n        return stakeData.staked\n    } else {\n        //Break the list in to 1024 chunks\n        let chunk = addrs.slice(0, 256)\n        let remainingChunk = addrs.slice(256)\n\n        let stakeData = await pChain.getStake(chunk)\n        let chunkStake = stakeData.staked\n        return chunkStake.add(await getStakeForAddresses(remainingChunk))\n    }\n}\n\nexport async function avmGetAllUTXOs(addrs: string[]): Promise<AVMUTXOSet> {\n    if (addrs.length <= 1024) {\n        let utxos = await avmGetAllUTXOsForAddresses(addrs)\n        return utxos\n    } else {\n        //Break the list in to 1024 chunks\n        let chunk = addrs.slice(0, 1024)\n        let remainingChunk = addrs.slice(1024)\n\n        let newSet = await avmGetAllUTXOsForAddresses(chunk)\n        return newSet.merge(await avmGetAllUTXOs(remainingChunk))\n    }\n}\n\nexport async function avmGetAllUTXOsForAddresses(\n    addrs: string[],\n    endIndex: any = undefined\n): Promise<AVMUTXOSet> {\n    if (addrs.length > 1024) throw new Error('Maximum length of addresses is 1024')\n    let response\n    if (!endIndex) {\n        response = await avm.getUTXOs(addrs)\n    } else {\n        response = await avm.getUTXOs(addrs, undefined, 0, endIndex)\n    }\n\n    let utxoSet = response.utxos\n    let utxos = utxoSet.getAllUTXOs()\n    let nextEndIndex = response.endIndex\n    let len = response.numFetched\n\n    if (len >= 1024) {\n        let subUtxos = await avmGetAllUTXOsForAddresses(addrs, nextEndIndex)\n        return utxoSet.merge(subUtxos)\n    }\n    return utxoSet\n}\n\n// helper method to get utxos for more than 1024 addresses\nexport async function platformGetAllUTXOs(addrs: string[]): Promise<PlatformUTXOSet> {\n    if (addrs.length <= 1024) {\n        let newSet = await platformGetAllUTXOsForAddresses(addrs)\n        return newSet\n    } else {\n        //Break the list in to 1024 chunks\n        let chunk = addrs.slice(0, 1024)\n        let remainingChunk = addrs.slice(1024)\n\n        let newSet = await platformGetAllUTXOsForAddresses(chunk)\n\n        return newSet.merge(await platformGetAllUTXOs(remainingChunk))\n    }\n}\n\nexport async function platformGetAllUTXOsForAddresses(\n    addrs: string[],\n    endIndex: any = undefined\n): Promise<PlatformUTXOSet> {\n    let response\n    if (!endIndex) {\n        response = await pChain.getUTXOs(addrs)\n    } else {\n        response = await pChain.getUTXOs(addrs, undefined, 0, endIndex)\n    }\n\n    let utxoSet = response.utxos\n    let nextEndIndex = response.endIndex\n    let len = response.numFetched\n\n    if (len >= 1024) {\n        let subUtxos = await platformGetAllUTXOsForAddresses(addrs, nextEndIndex)\n        return utxoSet.merge(subUtxos)\n    }\n\n    return utxoSet\n}\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { digestMessage } from '@/helpers/helper'\nimport { WalletNameType } from '@/js/wallets/types'\n\nimport { Buffer as BufferAvalanche } from 'avalanche'\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    UTXO,\n    UnsignedTx,\n} from 'avalanche/dist/apis/avm'\nimport {\n    KeyPair as PlatformKeyPair,\n    KeyChain as PlatformKeyChain,\n    UTXOSet as PlatformUTXOSet,\n    UTXOSet,\n} from 'avalanche/dist/apis/platformvm'\nimport { KeyChain, KeyChain as EVMKeyChain, UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm'\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport BN from 'bn.js'\nimport { buildUnsignedTransaction } from '../TxHelper'\nimport {\n    AvaWalletCore,\n    AvmExportChainType,\n    AvmImportChainType,\n    ChainAlias,\n    UnsafeWallet,\n} from './types'\nimport { UTXO as PlatformUTXO } from 'avalanche/dist/apis/platformvm/utxos'\nimport { privateToAddress } from 'ethereumjs-util'\nimport { Tx as AVMTx, UnsignedTx as AVMUnsignedTx } from 'avalanche/dist/apis/avm/tx'\nimport {\n    Tx as PlatformTx,\n    UnsignedTx as PlatformUnsignedTx,\n} from 'avalanche/dist/apis/platformvm/tx'\nimport { Tx as EvmTx, UnsignedTx as EVMUnsignedTx } from 'avalanche/dist/apis/evm/tx'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletCore } from '@/js/wallets/WalletCore'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from '@/helpers/utxo_helper'\nimport { UTXO as AVMUTXO } from 'avalanche/dist/apis/avm/utxos'\nimport { Transaction } from '@ethereumjs/tx'\n\nclass SingletonWallet extends WalletCore implements AvaWalletCore, UnsafeWallet {\n    keyChain: AVMKeyChain\n    keyPair: AVMKeyPair\n\n    platformKeyChain: PlatformKeyChain\n    platformKeyPair: PlatformKeyPair\n\n    chainId: string\n    chainIdP: string\n\n    key: string\n\n    stakeAmount: BN\n\n    type: WalletNameType\n\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethAddressBech: string\n    ethBalance: BN\n\n    constructor(pk: string) {\n        super()\n\n        this.key = pk\n\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.chainIdP = pChain.getBlockchainAlias() || pChain.getBlockchainID()\n\n        let hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.keyPair = this.keyChain.importKey(pk)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformKeyPair = this.platformKeyChain.importKey(pk)\n\n        this.stakeAmount = new BN(0)\n\n        // Derive EVM key and address\n        let pkBuf = bintools.cb58Decode(pk.split('-')[1])\n        let pkHex = pkBuf.toString('hex')\n        let pkBuffNative = Buffer.from(pkHex, 'hex')\n\n        this.ethKey = pkHex\n        this.ethAddress = privateToAddress(pkBuffNative).toString('hex')\n        this.ethBalance = new BN(0)\n\n        let cPrivKey = `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(pkBuf))\n        this.ethKeyBech = cPrivKey\n        let cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        let cKeypair = cKeyChain.importKey(cPrivKey)\n        this.ethAddressBech = cKeypair.getAddressString()\n\n        this.type = 'singleton'\n        this.isInit = true\n    }\n\n    getChangeAddressAvm(): string {\n        return this.getCurrentAddressAvm()\n    }\n\n    getCurrentAddressAvm(): string {\n        return this.keyPair.getAddressString()\n    }\n\n    getChangeAddressPlatform(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    getDerivedAddresses(): string[] {\n        let addr = this.getCurrentAddressAvm()\n        return [addr]\n    }\n\n    getDerivedAddressesP() {\n        return [this.getCurrentAddressPlatform()]\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.getDerivedAddresses()\n    }\n\n    getExtendedPlatformAddresses(): string[] {\n        let addr = this.platformKeyPair.getAddressString()\n        return [addr]\n    }\n\n    getHistoryAddresses(): string[] {\n        let addr = this.getCurrentAddressAvm()\n        return [addr]\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    getCurrentAddressPlatform(): string {\n        return this.platformKeyPair.getAddressString()\n    }\n\n    getBaseAddress(): string {\n        return this.getCurrentAddressAvm()\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    getUTXOSet(): AVMUTXOSet {\n        return this.utxoset\n    }\n\n    getPlatformUTXOSet(): PlatformUTXOSet {\n        return this.platformUtxoset\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    getEvmAddressBech(): string {\n        return this.ethAddressBech\n    }\n\n    async getEthBalance() {\n        let bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async updateUTXOsX(): Promise<AVMUTXOSet> {\n        let result = await avmGetAllUTXOs([this.getCurrentAddressAvm()])\n        this.utxoset = result\n        return result\n    }\n\n    async updateUTXOsP(): Promise<PlatformUTXOSet> {\n        let result = await platformGetAllUTXOs([this.getCurrentAddressPlatform()])\n        this.platformUtxoset = result\n        return result\n    }\n\n    async getUTXOs(): Promise<void> {\n        this.isFetchUtxos = true\n\n        await this.updateUTXOsX()\n        await this.updateUTXOsP()\n\n        await this.getStake()\n        await this.getEthBalance()\n\n        this.isFetchUtxos = false\n\n        return\n    }\n\n    async exportFromPChain(amt: BN) {\n        return await WalletHelper.exportFromPChain(this, amt)\n    }\n\n    async exportFromXChain(amt: BN, destinationChain: AvmExportChainType) {\n        return await WalletHelper.exportFromXChain(this, amt, destinationChain)\n    }\n\n    async exportFromCChain(amt: BN) {\n        return await WalletHelper.exportFromCChain(this, amt)\n    }\n\n    async importToPlatformChain(): Promise<string> {\n        return await WalletHelper.importToPlatformChain(this)\n    }\n\n    async importToXChain(sourceChain: AvmImportChainType): Promise<string> {\n        return await WalletHelper.importToXChain(this, sourceChain)\n    }\n\n    async importToCChain(): Promise<string> {\n        return await WalletHelper.importToCChain(this)\n    }\n\n    async buildUnsignedTransaction(\n        orders: (ITransaction | UTXO)[],\n        addr: string,\n        memo?: BufferAvalanche\n    ) {\n        const changeAddress = this.getChangeAddressAvm()\n        const derivedAddresses = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet() as AVMUTXOSet\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: BufferAvalanche | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    getFirstAvailableAddressPlatform(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    onnetworkchange(): void {\n        let hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.utxoset = new AVMUTXOSet()\n        this.keyPair = this.keyChain.importKey(this.key)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.platformKeyPair = this.platformKeyChain.importKey(this.key)\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        let cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethAddressBech = cKeypair.getAddressString()\n        this.ethBalance = new BN(0)\n\n        this.getUTXOs()\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        let keychain = this.keyChain\n\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        let keychain = this.platformKeyChain\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        let keyChain = this.ethKeyChain\n        return unsignedTx.sign(keyChain)\n    }\n\n    async signEvm(tx: Transaction) {\n        let keyBuff = Buffer.from(this.ethKey, 'hex')\n        return tx.sign(keyBuff)\n    }\n\n    async signMessage(msgStr: string): Promise<string> {\n        let digest = digestMessage(msgStr)\n\n        let digestHex = digest.toString('hex')\n        let digestBuff = BufferAvalanche.from(digestHex, 'hex')\n        let signed = this.keyPair.sign(digestBuff)\n\n        return bintools.cb58Encode(signed)\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n\n    getAllAddressesX() {\n        return [this.getCurrentAddressAvm()]\n    }\n\n    getAllAddressesP() {\n        return [this.getCurrentAddressPlatform()]\n    }\n}\n\nexport { SingletonWallet }\n","class AvaNftFamily {\n    id: string\n    name: string\n    symbol: string\n\n    constructor(id: string, name: string, symbol: string) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n    }\n}\n\nexport { AvaNftFamily }\n","/*\nThe base wallet class used for common functionality\n*/\nimport { BN } from 'avalanche'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm'\nvar uniqid = require('uniqid')\n\nabstract class WalletCore {\n    id: string\n\n    utxoset: AVMUTXOSet\n    platformUtxoset: PlatformUTXOSet\n    stakeAmount: BN\n\n    isFetchUtxos: boolean\n    isInit: boolean\n\n    constructor() {\n        this.id = uniqid()\n        this.utxoset = new AVMUTXOSet()\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.stakeAmount = new BN(0)\n\n        this.isInit = false\n        this.isFetchUtxos = false\n    }\n\n    abstract async signMessage(msg: string, address?: string): Promise<string>\n}\nexport { WalletCore }\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm'\nimport {\n    UTXOSet as PlatformUTXOSet,\n    UTXO as PlatformUTXO,\n} from 'avalanche/dist/apis/platformvm/utxos'\nimport { UTXOSet as AVMUTXOSet, UTXO as AVMUTXO } from 'avalanche/dist/apis/avm/utxos'\nimport { WalletType } from '@/js/wallets/types'\n\nimport { BN, Buffer } from 'avalanche'\nimport { Tx as AVMTx, UnsignedTx as AVMUnsignedTx } from 'avalanche/dist/apis/avm/tx'\nimport {\n    buildAvmExportTransaction,\n    buildCreateNftFamilyTx,\n    buildEvmExportTransaction,\n    buildEvmTransferErc20Tx,\n    buildEvmTransferErc721Tx,\n    buildEvmTransferNativeTx,\n    buildMintNftTx,\n} from '@/js/TxHelper'\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { ITransaction } from '@/components/wallet/transfer/types'\n\nimport { AvmExportChainType, AvmImportChainType } from '@/js/wallets/types'\nimport { web3 } from '@/evm'\nimport Erc20Token from '@/js/Erc20Token'\nimport { getStakeForAddresses } from '@/helpers/utxo_helper'\nimport ERC721Token from '@/js/ERC721Token'\n\nimport { UtxoHelper } from '@avalabs/avalanche-wallet-sdk'\nclass WalletHelper {\n    static async getStake(wallet: WalletType): Promise<BN> {\n        let addrs = wallet.getAllAddressesP()\n        return await getStakeForAddresses(addrs)\n    }\n\n    static async createNftFamily(\n        wallet: WalletType,\n        name: string,\n        symbol: string,\n        groupNum: number\n    ) {\n        let fromAddresses = wallet.getDerivedAddresses()\n        let changeAddress = wallet.getChangeAddressAvm()\n\n        let minterAddress = wallet.getCurrentAddressAvm()\n\n        let utxoSet = wallet.utxoset\n\n        let unsignedTx = await buildCreateNftFamilyTx(\n            name,\n            symbol,\n            groupNum,\n            fromAddresses,\n            minterAddress,\n            changeAddress,\n            utxoSet\n        )\n\n        let signed = await wallet.signX(unsignedTx)\n        return await avm.issueTx(signed)\n    }\n\n    static async mintNft(\n        wallet: WalletType,\n        mintUtxo: AVMUTXO,\n        payload: PayloadBase,\n        quantity: number\n    ) {\n        let ownerAddress = wallet.getCurrentAddressAvm()\n        let changeAddress = wallet.getChangeAddressAvm()\n\n        let sourceAddresses = wallet.getDerivedAddresses()\n\n        let utxoSet = wallet.utxoset\n        let tx = await buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            ownerAddress,\n            changeAddress,\n            sourceAddresses,\n            utxoSet\n        )\n        let signed = await wallet.signX(tx)\n        return await avm.issueTx(signed)\n    }\n\n    static async issueBatchTx(\n        wallet: WalletType,\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        let unsignedTx = await wallet.buildUnsignedTransaction(orders, addr, memo)\n        const tx = await wallet.signX(unsignedTx)\n        const txId: string = await avm.issueTx(tx)\n\n        return txId\n    }\n\n    static async validate(\n        wallet: WalletType,\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let utxoSet = wallet.getPlatformUTXOSet()\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        let pAddressStrings = wallet.getAllAddressesP()\n\n        let stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = wallet.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        let changeAddress = wallet.getFirstAvailableAddressPlatform()\n\n        let stakeReturnAddr = wallet.getCurrentAddressPlatform()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddValidatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings, // from\n            [changeAddress], // change\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress],\n            delegationFee\n        )\n\n        let tx = await wallet.signP(unsignedTx)\n        return await pChain.issueTx(tx)\n    }\n\n    static async delegate(\n        wallet: WalletType,\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let utxoSet = wallet.getPlatformUTXOSet()\n        let pAddressStrings = wallet.getAllAddressesP()\n\n        let stakeAmount = amt\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = wallet.getPlatformRewardAddress()\n        }\n\n        let stakeReturnAddr = wallet.getPlatformRewardAddress()\n\n        // For change address use first available on the platform chain\n        let changeAddress = wallet.getFirstAvailableAddressPlatform()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddDelegatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings,\n            [changeAddress],\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress] // reward address\n        )\n\n        const tx = await wallet.signP(unsignedTx)\n        return await pChain.issueTx(tx)\n    }\n\n    static async avmGetAtomicUTXOs(wallet: WalletType, sourceChain: AvmImportChainType) {\n        let addrs = wallet.getAllAddressesX()\n        return await UtxoHelper.avmGetAtomicUTXOs(addrs, sourceChain)\n    }\n\n    static async platformGetAtomicUTXOs(wallet: WalletType) {\n        let addrs = wallet.getAllAddressesP()\n        return await UtxoHelper.platformGetAtomicUTXOs(addrs)\n    }\n\n    static async evmGetAtomicUTXOs(wallet: WalletType) {\n        let addrs = [wallet.getEvmAddressBech()]\n        return await UtxoHelper.evmGetAtomicUTXOs(addrs)\n    }\n\n    static async importToXChain(wallet: WalletType, sourceChain: AvmImportChainType) {\n        const utxoSet = await this.avmGetAtomicUTXOs(wallet, sourceChain)\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let xToAddr = wallet.getCurrentAddressAvm()\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'X', addr))\n\n        let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        let sourceChainId\n        if (sourceChain === 'P') {\n            sourceChainId = pChain.getBlockchainID()\n        } else {\n            sourceChainId = cChain.getBlockchainID()\n        }\n\n        // Owner addresses, the addresses we exported to\n        const unsignedTx = await avm.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            sourceChainId,\n            [xToAddr],\n            fromAddrs,\n            [xToAddr]\n        )\n\n        const tx = await wallet.signX(unsignedTx)\n        return await avm.issueTx(tx)\n    }\n\n    static async importToPlatformChain(wallet: WalletType): Promise<string> {\n        const utxoSet = await this.platformGetAtomicUTXOs(wallet)\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        // Owner addresses, the addresses we exported to\n        let pToAddr = wallet.getCurrentAddressPlatform()\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'P', addr))\n\n        let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        const unsignedTx = await pChain.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            avm.getBlockchainID(),\n            [pToAddr],\n            [pToAddr],\n            [pToAddr],\n            undefined,\n            undefined\n        )\n        const tx = await wallet.signP(unsignedTx)\n\n        return pChain.issueTx(tx)\n    }\n\n    static async importToCChain(wallet: WalletType): Promise<string> {\n        let bechAddr = wallet.getEvmAddressBech()\n        let hexAddr = wallet.getEvmAddress()\n\n        let utxoSet = await this.evmGetAtomicUTXOs(wallet)\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let toAddress = '0x' + hexAddr\n        let ownerAddresses = [bechAddr]\n        let fromAddresses = ownerAddresses\n        let sourceChain = avm.getBlockchainID()\n\n        const unsignedTx = await cChain.buildImportTx(\n            utxoSet,\n            toAddress,\n            ownerAddresses,\n            sourceChain,\n            fromAddresses\n        )\n        let tx = await wallet.signC(unsignedTx)\n        let id = await cChain.issueTx(tx)\n\n        return id\n    }\n\n    static async exportFromXChain(\n        wallet: WalletType,\n        amt: BN,\n        destinationChain: AvmExportChainType\n    ) {\n        let fee = avm.getTxFee()\n        let amtFee = amt.add(fee)\n\n        let destinationAddr\n        if (destinationChain === 'P') {\n            destinationAddr = wallet.getCurrentAddressPlatform()\n        } else {\n            // C Chain\n            destinationAddr = wallet.getEvmAddressBech()\n        }\n\n        let fromAddresses = wallet.getAllAddressesX()\n        let changeAddress = wallet.getChangeAddressAvm()\n        let utxos = wallet.getUTXOSet()\n        let exportTx = (await buildAvmExportTransaction(\n            destinationChain,\n            utxos,\n            fromAddresses,\n            destinationAddr,\n            amtFee,\n            changeAddress\n        )) as AVMUnsignedTx\n\n        let tx = await wallet.signX(exportTx)\n\n        return avm.issueTx(tx)\n    }\n\n    static async exportFromPChain(wallet: WalletType, amt: BN) {\n        let fee = avm.getTxFee()\n        let amtFee = amt.add(fee)\n\n        let utxoSet = wallet.getPlatformUTXOSet()\n        let destinationAddr = wallet.getCurrentAddressAvm()\n\n        let pChangeAddr = wallet.getCurrentAddressPlatform()\n        let fromAddrs = wallet.getAllAddressesP()\n\n        let xId = avm.getBlockchainID()\n\n        let exportTx = await pChain.buildExportTx(\n            utxoSet,\n            amtFee,\n            xId,\n            [destinationAddr],\n            fromAddrs,\n            [pChangeAddr]\n        )\n\n        let tx = await wallet.signP(exportTx)\n        return await pChain.issueTx(tx)\n    }\n\n    static async exportFromCChain(wallet: WalletType, amt: BN) {\n        let fee = avm.getTxFee()\n        let amtFee = amt.add(fee)\n\n        let hexAddr = wallet.getEvmAddress()\n        let bechAddr = wallet.getEvmAddressBech()\n\n        let fromAddresses = [hexAddr]\n        let destinationAddr = wallet.getCurrentAddressAvm()\n\n        let exportTx = await buildEvmExportTransaction(\n            fromAddresses,\n            destinationAddr,\n            amtFee,\n            bechAddr\n        )\n\n        let tx = await wallet.signC(exportTx)\n        return cChain.issueTx(tx)\n    }\n\n    static async getEthBalance(wallet: WalletType) {\n        let bal = await web3.eth.getBalance(wallet.ethAddress)\n        return new BN(bal)\n    }\n\n    static async sendEth(\n        wallet: WalletType,\n        to: string,\n        amount: BN, // in wei\n        gasPrice: BN,\n        gasLimit: number\n    ) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n\n        let tx = await buildEvmTransferNativeTx(fromAddr, to, amount, gasPrice, gasLimit)\n\n        let signedTx = await wallet.signEvm(tx)\n\n        let txHex = signedTx.serialize().toString('hex')\n        let hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async sendErc20(\n        wallet: WalletType,\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n        let tx = await buildEvmTransferErc20Tx(fromAddr, to, amount, gasPrice, gasLimit, token)\n\n        let signedTx = await wallet.signEvm(tx)\n        let txHex = signedTx.serialize().toString('hex')\n        let hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async sendErc721(\n        wallet: WalletType,\n        to: string,\n        gasPrice: BN,\n        gasLimit: number,\n        token: ERC721Token,\n        tokenId: string\n    ) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n        let tx = await buildEvmTransferErc721Tx(fromAddr, to, gasPrice, gasLimit, token, tokenId)\n        let signedTx = await wallet.signEvm(tx)\n        let txHex = signedTx.serialize().toString('hex')\n        let hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async estimateTxGas(wallet: WalletType, tx: any) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n        let estGas = await tx.estimateGas({ from: fromAddr })\n        return Math.round(estGas * 1.1)\n    }\n\n    static async estimateGas(wallet: WalletType, to: string, amount: BN, token: Erc20Token) {\n        let from = '0x' + wallet.getEvmAddress()\n        let tx = token.createTransferTx(to, amount)\n        let estGas = await tx.estimateGas({\n            from: from,\n        })\n        // Return 10% more\n        return Math.round(estGas * 1.1)\n    }\n}\n\nexport { WalletHelper }\n","import store from '@/store/index'\nimport { ava } from '@/AVA'\n\nimport {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    NFTTransferOutput,\n    UTXO,\n} from 'avalanche/dist/apis/avm'\n\nimport { Defaults, getPreferredHRP, ONEDJTX, PayloadBase, PayloadTypes } from 'avalanche/dist/utils'\nimport { BN } from 'avalanche/dist'\nimport Big from 'big.js'\n\nimport { Buffer } from 'avalanche'\nimport createHash from 'create-hash'\n\nfunction getAssetIcon(id: string) {\n    let url = '/question-solid.svg'\n    let AVA = store.getters['Assets/AssetAVA']\n\n    if (!AVA) return url\n    if (id === AVA.id) {\n        return '/djt_letter_icon.png'\n    }\n    return url\n}\n\nfunction bnToBig(val: BN, denomination = 0): Big {\n    return new Big(val.toString()).div(Math.pow(10, denomination))\n}\n\nfunction keyToKeypair(key: string, chainID: string = 'X'): AVMKeyPair {\n    let hrp = getPreferredHRP(ava.getNetworkID())\n    let keychain = new AVMKeyChain(hrp, chainID)\n    return keychain.importKey(key)\n}\n\nfunction calculateStakingReward(amount: BN, duration: number, currentSupply: BN): BN {\n    let networkID = ava.getNetworkID()\n\n    //@ts-ignore\n    let defValues = Defaults.network[networkID]\n\n    if (!defValues) {\n        console.error('Network default values not found.')\n        return new BN(0)\n    }\n    defValues = defValues.P\n\n    let maxConsumption: number = defValues.maxConsumption\n    let minConsumption: number = defValues.minConsumption\n    let diffConsumption = maxConsumption - minConsumption\n    let maxSupply: BN = defValues.maxSupply\n    let maxStakingDuration: BN = defValues.maxStakingDuration\n    let remainingSupply = maxSupply.sub(currentSupply)\n\n    let amtBig = Big(amount.div(ONEDJTX).toString())\n    let currentSupplyBig = Big(currentSupply.div(ONEDJTX).toString())\n    let remainingSupplyBig = Big(remainingSupply.div(ONEDJTX).toString())\n    let portionOfExistingSupplyBig = amtBig.div(currentSupplyBig)\n\n    let portionOfStakingDuration = duration / maxStakingDuration.toNumber()\n    let mintingRate = minConsumption + diffConsumption * portionOfStakingDuration\n\n    let rewardBig: Big = remainingSupplyBig.times(portionOfExistingSupplyBig)\n    rewardBig = rewardBig.times(Big(mintingRate * portionOfStakingDuration))\n\n    let rewardStr = rewardBig.times(Math.pow(10, 9)).toFixed(0)\n    let rewardBN = new BN(rewardStr)\n\n    return rewardBN\n}\n\nfunction digestMessage(msgStr: string) {\n    let mBuf = Buffer.from(msgStr, 'utf8')\n    let msgSize = Buffer.alloc(4)\n    msgSize.writeUInt32BE(mBuf.length, 0)\n    let msgBuf = Buffer.from(`\\x1AAvalanche Signed Message:\\n${msgSize}${msgStr}`, 'utf8')\n    return createHash('sha256').update(msgBuf).digest()\n}\n\nlet payloadtypes = PayloadTypes.getInstance()\n\nfunction getPayloadFromUTXO(utxo: UTXO): PayloadBase {\n    let out = utxo.getOutput() as NFTTransferOutput\n    let payload = out.getPayloadBuffer()\n\n    let typeId = payloadtypes.getTypeID(payload)\n    let pl: Buffer = payloadtypes.getContent(payload)\n    let payloadbase: PayloadBase = payloadtypes.select(typeId, pl)\n\n    return payloadbase\n}\n\nexport {\n    getAssetIcon,\n    keyToKeypair,\n    calculateStakingReward,\n    bnToBig,\n    digestMessage,\n    getPayloadFromUTXO,\n}\n","// Manages BigNumber and Ava conversion and arithmetic\nimport BN from 'bn.js'\nimport Big from 'big.js'\n\nclass AvaAsset {\n    id: string\n    name: string\n    symbol: string\n    denomination: number\n    amount: BN\n    amountLocked: BN\n    // DJTX P chain, Wallet Staking\n    amountExtra: BN\n    private readonly pow: Big\n    constructor(id: string, name: string, symbol: string, denomination: number) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n        this.denomination = denomination\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n        this.pow = Big(10).pow(denomination)\n    }\n\n    addBalance(val: BN): void {\n        this.amount = this.amount.add(val)\n    }\n\n    addBalanceLocked(val: BN): void {\n        this.amountLocked = this.amountLocked.add(val)\n    }\n\n    addExtra(val: BN): void {\n        this.amountExtra = this.amountExtra.add(val)\n    }\n\n    resetBalance() {\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n    }\n\n    getAmount(locked: boolean = false): Big {\n        if (!locked) {\n            return Big(this.amount.toString(10)).div(this.pow)\n        } else {\n            return Big(this.amountLocked.toString(10)).div(this.pow)\n        }\n    }\n\n    getAmountBN(locked: boolean = false): BN {\n        if (!locked) {\n            return this.amount\n        } else {\n            return this.amountLocked\n        }\n    }\n\n    getTotalAmount(): BN {\n        return this.amount.add(this.amountLocked).add(this.amountExtra)\n    }\n\n    toStringTotal(): string {\n        let big: Big = Big(this.getTotalAmount().toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n    }\n\n    toString() {\n        let big: Big = Big(this.amount.toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n        // if(big.lt(Big('0.001'))){\n        //     return big.toLocaleString(this.denomination);\n        // }else{\n        //     let min = Math.min(this.denomination, 2);\n        //     return big.toLocaleString(min);\n        // }\n    }\n}\n\nexport default AvaAsset\n"],"sourceRoot":""}